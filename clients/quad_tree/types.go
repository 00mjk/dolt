// This file was generated by nomgen.
// To regenerate, run `go generate` in this package.

package main

import (
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

// Geonode

type Geonode struct {
	m types.Map
}

func NewGeonode() Geonode {
	return Geonode{
		types.NewMap(types.NewString("$name"), types.NewString("Geonode")),
	}
}

func GeonodeFromVal(v types.Value) Geonode {
	return Geonode{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s Geonode) NomsValue() types.Map {
	return s.m
}

func (s Geonode) Equals(p Geonode) bool {
	return s.m.Equals(p.m)
}

func (s Geonode) Ref() ref.Ref {
	return s.m.Ref()
}

func (s Geonode) Geoposition() Geoposition {
	return GeopositionFromVal(s.m.Get(types.NewString("geoposition")))
}

func (s Geonode) SetGeoposition(p Geoposition) Geonode {
	return GeonodeFromVal(s.m.Set(types.NewString("geoposition"), p.NomsValue()))
}

// Geoposition

type Geoposition struct {
	m types.Map
}

func NewGeoposition() Geoposition {
	return Geoposition{
		types.NewMap(types.NewString("$name"), types.NewString("Geoposition")),
	}
}

func GeopositionFromVal(v types.Value) Geoposition {
	return Geoposition{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s Geoposition) NomsValue() types.Map {
	return s.m
}

func (s Geoposition) Equals(p Geoposition) bool {
	return s.m.Equals(p.m)
}

func (s Geoposition) Ref() ref.Ref {
	return s.m.Ref()
}

func (s Geoposition) Longitude() types.Float32 {
	return types.Float32FromVal(s.m.Get(types.NewString("longitude")))
}

func (s Geoposition) SetLongitude(p types.Float32) Geoposition {
	return GeopositionFromVal(s.m.Set(types.NewString("longitude"), p))
}

func (s Geoposition) Latitude() types.Float32 {
	return types.Float32FromVal(s.m.Get(types.NewString("latitude")))
}

func (s Geoposition) SetLatitude(p types.Float32) Geoposition {
	return GeopositionFromVal(s.m.Set(types.NewString("latitude"), p))
}

// Georectangle

type Georectangle struct {
	m types.Map
}

func NewGeorectangle() Georectangle {
	return Georectangle{
		types.NewMap(types.NewString("$name"), types.NewString("Georectangle")),
	}
}

func GeorectangleFromVal(v types.Value) Georectangle {
	return Georectangle{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s Georectangle) NomsValue() types.Map {
	return s.m
}

func (s Georectangle) Equals(p Georectangle) bool {
	return s.m.Equals(p.m)
}

func (s Georectangle) Ref() ref.Ref {
	return s.m.Ref()
}

func (s Georectangle) BottomRight() Geoposition {
	return GeopositionFromVal(s.m.Get(types.NewString("BottomRight")))
}

func (s Georectangle) SetBottomRight(p Geoposition) Georectangle {
	return GeorectangleFromVal(s.m.Set(types.NewString("BottomRight"), p.NomsValue()))
}

func (s Georectangle) TopLeft() Geoposition {
	return GeopositionFromVal(s.m.Get(types.NewString("TopLeft")))
}

func (s Georectangle) SetTopLeft(p Geoposition) Georectangle {
	return GeorectangleFromVal(s.m.Set(types.NewString("TopLeft"), p.NomsValue()))
}

// ListOfGeonode

type ListOfGeonode struct {
	l types.List
}

type ListOfGeonodeIterCallback (func (p Geonode) (stop bool))

func NewListOfGeonode() ListOfGeonode {
	return ListOfGeonode{types.NewList()}
}

func ListOfGeonodeFromVal(p types.Value) ListOfGeonode {
	return ListOfGeonode{p.(types.List)}
}

func (l ListOfGeonode) NomsValue() types.List {
	return l.l
}

func (l ListOfGeonode) Equals(p ListOfGeonode) bool {
	return l.l.Equals(p.l)
}

func (l ListOfGeonode) Ref() ref.Ref {
	return l.l.Ref()
}

func (l ListOfGeonode) Len() uint64 {
	return l.l.Len()
}

func (l ListOfGeonode) Empty() bool {
	return l.Len() == uint64(0)
}

func (l ListOfGeonode) Get(idx uint64) Geonode {
	return GeonodeFromVal(l.l.Get(idx))
}

func (l ListOfGeonode) Slice(idx uint64, end uint64) ListOfGeonode {
	return ListOfGeonode{l.l.Slice(idx, end)}
}

func (l ListOfGeonode) Set(idx uint64, v Geonode) ListOfGeonode {
	return ListOfGeonode{l.l.Set(idx, v.NomsValue())}
}

func (l ListOfGeonode) Append(v ...Geonode) ListOfGeonode {
	return ListOfGeonode{l.l.Append(l.fromElemSlice(v)...)}
}

func (l ListOfGeonode) Insert(idx uint64, v ...Geonode) ListOfGeonode {
	return ListOfGeonode{l.l.Insert(idx, l.fromElemSlice(v)...)}
}

func (l ListOfGeonode) Remove(idx uint64, end uint64) ListOfGeonode {
	return ListOfGeonode{l.l.Remove(idx, end)}
}

func (l ListOfGeonode) RemoveAt(idx uint64) ListOfGeonode {
	return ListOfGeonode{(l.l.RemoveAt(idx))}
}

func (l ListOfGeonode) fromElemSlice(p []Geonode) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v.NomsValue()
	}
	return r
}

// QuadTree

type QuadTree struct {
	m types.Map
}

func NewQuadTree() QuadTree {
	return QuadTree{
		types.NewMap(types.NewString("$name"), types.NewString("QuadTree")),
	}
}

func QuadTreeFromVal(v types.Value) QuadTree {
	return QuadTree{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s QuadTree) NomsValue() types.Map {
	return s.m
}

func (s QuadTree) Equals(p QuadTree) bool {
	return s.m.Equals(p.m)
}

func (s QuadTree) Ref() ref.Ref {
	return s.m.Ref()
}

func (s QuadTree) Path() types.String {
	return types.StringFromVal(s.m.Get(types.NewString("Path")))
}

func (s QuadTree) SetPath(p types.String) QuadTree {
	return QuadTreeFromVal(s.m.Set(types.NewString("Path"), p))
}

func (s QuadTree) Nodes() ListOfGeonode {
	return ListOfGeonodeFromVal(s.m.Get(types.NewString("Nodes")))
}

func (s QuadTree) SetNodes(p ListOfGeonode) QuadTree {
	return QuadTreeFromVal(s.m.Set(types.NewString("Nodes"), p.NomsValue()))
}

func (s QuadTree) Georectangle() Georectangle {
	return GeorectangleFromVal(s.m.Get(types.NewString("Georectangle")))
}

func (s QuadTree) SetGeorectangle(p Georectangle) QuadTree {
	return QuadTreeFromVal(s.m.Set(types.NewString("Georectangle"), p.NomsValue()))
}

func (s QuadTree) Depth() types.UInt8 {
	return types.UInt8FromVal(s.m.Get(types.NewString("Depth")))
}

func (s QuadTree) SetDepth(p types.UInt8) QuadTree {
	return QuadTreeFromVal(s.m.Set(types.NewString("Depth"), p))
}

func (s QuadTree) NumDescendents() types.UInt64 {
	return types.UInt64FromVal(s.m.Get(types.NewString("NumDescendents")))
}

func (s QuadTree) SetNumDescendents(p types.UInt64) QuadTree {
	return QuadTreeFromVal(s.m.Set(types.NewString("NumDescendents"), p))
}

func (s QuadTree) Children() MapOfStringToQuadTree {
	return MapOfStringToQuadTreeFromVal(s.m.Get(types.NewString("Children")))
}

func (s QuadTree) SetChildren(p MapOfStringToQuadTree) QuadTree {
	return QuadTreeFromVal(s.m.Set(types.NewString("Children"), p.NomsValue()))
}

// MapOfStringToQuadTree

type MapOfStringToQuadTree struct {
	m types.Map
}

type MapOfStringToQuadTreeIterCallback (func(k types.String, v QuadTree) (stop bool))

func NewMapOfStringToQuadTree() MapOfStringToQuadTree {
	return MapOfStringToQuadTree{types.NewMap()}
}

func MapOfStringToQuadTreeFromVal(p types.Value) MapOfStringToQuadTree {
	return MapOfStringToQuadTree{p.(types.Map)}
}

func (m MapOfStringToQuadTree) NomsValue() types.Map {
	return m.m
}

func (m MapOfStringToQuadTree) Equals(p MapOfStringToQuadTree) bool {
	return m.m.Equals(p.m)
}

func (m MapOfStringToQuadTree) Ref() ref.Ref {
	return m.m.Ref()
}

func (m MapOfStringToQuadTree) Empty() bool {
	return m.m.Empty()
}

func (m MapOfStringToQuadTree) Len() uint64 {
	return m.m.Len()
}

func (m MapOfStringToQuadTree) Has(p types.String) bool {
	return m.m.Has(p)
}

func (m MapOfStringToQuadTree) Get(p types.String) QuadTree {
	return QuadTreeFromVal(m.m.Get(p))
}

func (m MapOfStringToQuadTree) Set(k types.String, v QuadTree) MapOfStringToQuadTree {
	return MapOfStringToQuadTreeFromVal(m.m.Set(k, v.NomsValue()))
}

// TODO: Implement SetM?

func (m MapOfStringToQuadTree) Remove(p types.String) MapOfStringToQuadTree {
	return MapOfStringToQuadTreeFromVal(m.m.Remove(p))
}

func (m MapOfStringToQuadTree) Iter(cb MapOfStringToQuadTreeIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(types.StringFromVal(k), QuadTreeFromVal(v))
	})
}


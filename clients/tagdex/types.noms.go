// This file was generated by nomdl/codegen.

package main

import (
	"github.com/attic-labs/noms/chunks"
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

// MapOfStringToSetOfRefOfRemotePhoto

type MapOfStringToSetOfRefOfRemotePhoto struct {
	m   types.Map
	cs  chunks.ChunkStore
	ref *ref.Ref
}

func NewMapOfStringToSetOfRefOfRemotePhoto(cs chunks.ChunkStore) MapOfStringToSetOfRefOfRemotePhoto {
	return MapOfStringToSetOfRefOfRemotePhoto{types.NewTypedMap(cs, __typeForMapOfStringToSetOfRefOfRemotePhoto), cs, &ref.Ref{}}
}

type MapOfStringToSetOfRefOfRemotePhotoDef map[string]SetOfRefOfRemotePhotoDef

func (def MapOfStringToSetOfRefOfRemotePhotoDef) New(cs chunks.ChunkStore) MapOfStringToSetOfRefOfRemotePhoto {
	kv := make([]types.Value, 0, len(def)*2)
	for k, v := range def {
		kv = append(kv, types.NewString(k), v.New(cs))
	}
	return MapOfStringToSetOfRefOfRemotePhoto{types.NewTypedMap(cs, __typeForMapOfStringToSetOfRefOfRemotePhoto, kv...), cs, &ref.Ref{}}
}

func (m MapOfStringToSetOfRefOfRemotePhoto) Def() MapOfStringToSetOfRefOfRemotePhotoDef {
	def := make(map[string]SetOfRefOfRemotePhotoDef)
	m.m.Iter(func(k, v types.Value) bool {
		def[k.(types.String).String()] = v.(SetOfRefOfRemotePhoto).Def()
		return false
	})
	return def
}

func (m MapOfStringToSetOfRefOfRemotePhoto) Equals(other types.Value) bool {
	return other != nil && __typeForMapOfStringToSetOfRefOfRemotePhoto.Equals(other.Type()) && m.Ref() == other.Ref()
}

func (m MapOfStringToSetOfRefOfRemotePhoto) Ref() ref.Ref {
	return types.EnsureRef(m.ref, m)
}

func (m MapOfStringToSetOfRefOfRemotePhoto) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, m.Type().Chunks()...)
	chunks = append(chunks, m.m.Chunks()...)
	return
}

func (m MapOfStringToSetOfRefOfRemotePhoto) ChildValues() []types.Value {
	return append([]types.Value{}, m.m.ChildValues()...)
}

// A Noms Value that describes MapOfStringToSetOfRefOfRemotePhoto.
var __typeForMapOfStringToSetOfRefOfRemotePhoto types.Type

func (m MapOfStringToSetOfRefOfRemotePhoto) Type() types.Type {
	return __typeForMapOfStringToSetOfRefOfRemotePhoto
}

func init() {
	__typeForMapOfStringToSetOfRefOfRemotePhoto = types.MakeCompoundType(types.MapKind, types.MakePrimitiveType(types.StringKind), types.MakeCompoundType(types.SetKind, types.MakeCompoundType(types.RefKind, types.MakeType(ref.Parse("sha1-a9eaf3ae0d9dde3722ad4c2a7322adc2dabc1690"), 0))))
	types.RegisterValue(__typeForMapOfStringToSetOfRefOfRemotePhoto, builderForMapOfStringToSetOfRefOfRemotePhoto, readerForMapOfStringToSetOfRefOfRemotePhoto)
}

func builderForMapOfStringToSetOfRefOfRemotePhoto(cs chunks.ChunkStore, v types.Value) types.Value {
	return MapOfStringToSetOfRefOfRemotePhoto{v.(types.Map), cs, &ref.Ref{}}
}

func readerForMapOfStringToSetOfRefOfRemotePhoto(v types.Value) types.Value {
	return v.(MapOfStringToSetOfRefOfRemotePhoto).m
}

func (m MapOfStringToSetOfRefOfRemotePhoto) Empty() bool {
	return m.m.Empty()
}

func (m MapOfStringToSetOfRefOfRemotePhoto) Len() uint64 {
	return m.m.Len()
}

func (m MapOfStringToSetOfRefOfRemotePhoto) Has(p string) bool {
	return m.m.Has(types.NewString(p))
}

func (m MapOfStringToSetOfRefOfRemotePhoto) Get(p string) SetOfRefOfRemotePhoto {
	return m.m.Get(types.NewString(p)).(SetOfRefOfRemotePhoto)
}

func (m MapOfStringToSetOfRefOfRemotePhoto) MaybeGet(p string) (SetOfRefOfRemotePhoto, bool) {
	v, ok := m.m.MaybeGet(types.NewString(p))
	if !ok {
		return NewSetOfRefOfRemotePhoto(m.cs), false
	}
	return v.(SetOfRefOfRemotePhoto), ok
}

func (m MapOfStringToSetOfRefOfRemotePhoto) Set(k string, v SetOfRefOfRemotePhoto) MapOfStringToSetOfRefOfRemotePhoto {
	return MapOfStringToSetOfRefOfRemotePhoto{m.m.Set(types.NewString(k), v), m.cs, &ref.Ref{}}
}

// TODO: Implement SetM?

func (m MapOfStringToSetOfRefOfRemotePhoto) Remove(p string) MapOfStringToSetOfRefOfRemotePhoto {
	return MapOfStringToSetOfRefOfRemotePhoto{m.m.Remove(types.NewString(p)), m.cs, &ref.Ref{}}
}

type MapOfStringToSetOfRefOfRemotePhotoIterCallback func(k string, v SetOfRefOfRemotePhoto) (stop bool)

func (m MapOfStringToSetOfRefOfRemotePhoto) Iter(cb MapOfStringToSetOfRefOfRemotePhotoIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(k.(types.String).String(), v.(SetOfRefOfRemotePhoto))
	})
}

type MapOfStringToSetOfRefOfRemotePhotoIterAllCallback func(k string, v SetOfRefOfRemotePhoto)

func (m MapOfStringToSetOfRefOfRemotePhoto) IterAll(cb MapOfStringToSetOfRefOfRemotePhotoIterAllCallback) {
	m.m.IterAll(func(k, v types.Value) {
		cb(k.(types.String).String(), v.(SetOfRefOfRemotePhoto))
	})
}

func (m MapOfStringToSetOfRefOfRemotePhoto) IterAllP(concurrency int, cb MapOfStringToSetOfRefOfRemotePhotoIterAllCallback) {
	m.m.IterAllP(concurrency, func(k, v types.Value) {
		cb(k.(types.String).String(), v.(SetOfRefOfRemotePhoto))
	})
}

type MapOfStringToSetOfRefOfRemotePhotoFilterCallback func(k string, v SetOfRefOfRemotePhoto) (keep bool)

func (m MapOfStringToSetOfRefOfRemotePhoto) Filter(cb MapOfStringToSetOfRefOfRemotePhotoFilterCallback) MapOfStringToSetOfRefOfRemotePhoto {
	out := m.m.Filter(func(k, v types.Value) bool {
		return cb(k.(types.String).String(), v.(SetOfRefOfRemotePhoto))
	})
	return MapOfStringToSetOfRefOfRemotePhoto{out, m.cs, &ref.Ref{}}
}

// SetOfRefOfRemotePhoto

type SetOfRefOfRemotePhoto struct {
	s   types.Set
	cs  chunks.ChunkStore
	ref *ref.Ref
}

func NewSetOfRefOfRemotePhoto(cs chunks.ChunkStore) SetOfRefOfRemotePhoto {
	return SetOfRefOfRemotePhoto{types.NewTypedSet(cs, __typeForSetOfRefOfRemotePhoto), cs, &ref.Ref{}}
}

type SetOfRefOfRemotePhotoDef map[ref.Ref]bool

func (def SetOfRefOfRemotePhotoDef) New(cs chunks.ChunkStore) SetOfRefOfRemotePhoto {
	l := make([]types.Value, len(def))
	i := 0
	for d, _ := range def {
		l[i] = NewRefOfRemotePhoto(d)
		i++
	}
	return SetOfRefOfRemotePhoto{types.NewTypedSet(cs, __typeForSetOfRefOfRemotePhoto, l...), cs, &ref.Ref{}}
}

func (s SetOfRefOfRemotePhoto) Def() SetOfRefOfRemotePhotoDef {
	def := make(map[ref.Ref]bool, s.Len())
	s.s.Iter(func(v types.Value) bool {
		def[v.(RefOfRemotePhoto).TargetRef()] = true
		return false
	})
	return def
}

func (s SetOfRefOfRemotePhoto) Equals(other types.Value) bool {
	return other != nil && __typeForSetOfRefOfRemotePhoto.Equals(other.Type()) && s.Ref() == other.Ref()
}

func (s SetOfRefOfRemotePhoto) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s SetOfRefOfRemotePhoto) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, s.Type().Chunks()...)
	chunks = append(chunks, s.s.Chunks()...)
	return
}

func (s SetOfRefOfRemotePhoto) ChildValues() []types.Value {
	return append([]types.Value{}, s.s.ChildValues()...)
}

// A Noms Value that describes SetOfRefOfRemotePhoto.
var __typeForSetOfRefOfRemotePhoto types.Type

func (m SetOfRefOfRemotePhoto) Type() types.Type {
	return __typeForSetOfRefOfRemotePhoto
}

func init() {
	__typeForSetOfRefOfRemotePhoto = types.MakeCompoundType(types.SetKind, types.MakeCompoundType(types.RefKind, types.MakeType(ref.Parse("sha1-a9eaf3ae0d9dde3722ad4c2a7322adc2dabc1690"), 0)))
	types.RegisterValue(__typeForSetOfRefOfRemotePhoto, builderForSetOfRefOfRemotePhoto, readerForSetOfRefOfRemotePhoto)
}

func builderForSetOfRefOfRemotePhoto(cs chunks.ChunkStore, v types.Value) types.Value {
	return SetOfRefOfRemotePhoto{v.(types.Set), cs, &ref.Ref{}}
}

func readerForSetOfRefOfRemotePhoto(v types.Value) types.Value {
	return v.(SetOfRefOfRemotePhoto).s
}

func (s SetOfRefOfRemotePhoto) Empty() bool {
	return s.s.Empty()
}

func (s SetOfRefOfRemotePhoto) Len() uint64 {
	return s.s.Len()
}

func (s SetOfRefOfRemotePhoto) Has(p RefOfRemotePhoto) bool {
	return s.s.Has(p)
}

type SetOfRefOfRemotePhotoIterCallback func(p RefOfRemotePhoto) (stop bool)

func (s SetOfRefOfRemotePhoto) Iter(cb SetOfRefOfRemotePhotoIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(v.(RefOfRemotePhoto))
	})
}

type SetOfRefOfRemotePhotoIterAllCallback func(p RefOfRemotePhoto)

func (s SetOfRefOfRemotePhoto) IterAll(cb SetOfRefOfRemotePhotoIterAllCallback) {
	s.s.IterAll(func(v types.Value) {
		cb(v.(RefOfRemotePhoto))
	})
}

func (s SetOfRefOfRemotePhoto) IterAllP(concurrency int, cb SetOfRefOfRemotePhotoIterAllCallback) {
	s.s.IterAllP(concurrency, func(v types.Value) {
		cb(v.(RefOfRemotePhoto))
	})
}

type SetOfRefOfRemotePhotoFilterCallback func(p RefOfRemotePhoto) (keep bool)

func (s SetOfRefOfRemotePhoto) Filter(cb SetOfRefOfRemotePhotoFilterCallback) SetOfRefOfRemotePhoto {
	out := s.s.Filter(func(v types.Value) bool {
		return cb(v.(RefOfRemotePhoto))
	})
	return SetOfRefOfRemotePhoto{out, s.cs, &ref.Ref{}}
}

func (s SetOfRefOfRemotePhoto) Insert(p ...RefOfRemotePhoto) SetOfRefOfRemotePhoto {
	return SetOfRefOfRemotePhoto{s.s.Insert(s.fromElemSlice(p)...), s.cs, &ref.Ref{}}
}

func (s SetOfRefOfRemotePhoto) Remove(p ...RefOfRemotePhoto) SetOfRefOfRemotePhoto {
	return SetOfRefOfRemotePhoto{s.s.Remove(s.fromElemSlice(p)...), s.cs, &ref.Ref{}}
}

func (s SetOfRefOfRemotePhoto) Union(others ...SetOfRefOfRemotePhoto) SetOfRefOfRemotePhoto {
	return SetOfRefOfRemotePhoto{s.s.Union(s.fromStructSlice(others)...), s.cs, &ref.Ref{}}
}

func (s SetOfRefOfRemotePhoto) First() RefOfRemotePhoto {
	return s.s.First().(RefOfRemotePhoto)
}

func (s SetOfRefOfRemotePhoto) fromStructSlice(p []SetOfRefOfRemotePhoto) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s SetOfRefOfRemotePhoto) fromElemSlice(p []RefOfRemotePhoto) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v
	}
	return r
}

// RefOfRemotePhoto

type RefOfRemotePhoto struct {
	target ref.Ref
	ref    *ref.Ref
}

func NewRefOfRemotePhoto(target ref.Ref) RefOfRemotePhoto {
	return RefOfRemotePhoto{target, &ref.Ref{}}
}

func (r RefOfRemotePhoto) TargetRef() ref.Ref {
	return r.target
}

func (r RefOfRemotePhoto) Ref() ref.Ref {
	return types.EnsureRef(r.ref, r)
}

func (r RefOfRemotePhoto) Equals(other types.Value) bool {
	return other != nil && __typeForRefOfRemotePhoto.Equals(other.Type()) && r.Ref() == other.Ref()
}

func (r RefOfRemotePhoto) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, r.Type().Chunks()...)
	chunks = append(chunks, r.target)
	return
}

func (r RefOfRemotePhoto) ChildValues() []types.Value {
	return nil
}

// A Noms Value that describes RefOfRemotePhoto.
var __typeForRefOfRemotePhoto types.Type

func (r RefOfRemotePhoto) Type() types.Type {
	return __typeForRefOfRemotePhoto
}

func (r RefOfRemotePhoto) Less(other types.OrderedValue) bool {
	return r.TargetRef().Less(other.(types.RefBase).TargetRef())
}

func init() {
	__typeForRefOfRemotePhoto = types.MakeCompoundType(types.RefKind, types.MakeType(ref.Parse("sha1-a9eaf3ae0d9dde3722ad4c2a7322adc2dabc1690"), 0))
	types.RegisterRef(__typeForRefOfRemotePhoto, builderForRefOfRemotePhoto)
}

func builderForRefOfRemotePhoto(r ref.Ref) types.Value {
	return NewRefOfRemotePhoto(r)
}

func (r RefOfRemotePhoto) TargetValue(cs chunks.ChunkStore) RemotePhoto {
	return types.ReadValue(r.target, cs).(RemotePhoto)
}

func (r RefOfRemotePhoto) SetTargetValue(val RemotePhoto, cs chunks.ChunkSink) RefOfRemotePhoto {
	return NewRefOfRemotePhoto(types.WriteValue(val, cs))
}

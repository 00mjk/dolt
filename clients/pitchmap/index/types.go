// This file was generated by nomgen.
// To regenerate, run `go generate` in this package.

package main

import (
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

// PitchList

type PitchList struct {
	l types.List
}

type PitchListIterCallback (func (p Pitch) (stop bool))

func NewPitchList() PitchList {
	return PitchList{types.NewList()}
}

func PitchListFromVal(p types.Value) PitchList {
	return PitchList{p.(types.List)}
}

func (l PitchList) NomsValue() types.List {
	return l.l
}

func (l PitchList) Equals(p PitchList) bool {
	return l.l.Equals(p.l)
}

func (l PitchList) Ref() ref.Ref {
	return l.l.Ref()
}

func (l PitchList) Len() uint64 {
	return l.l.Len()
}

func (l PitchList) Get(idx uint64) Pitch {
	return PitchFromVal(l.l.Get(idx))
}

func (l PitchList) Slice(idx uint64, end uint64) PitchList {
	return PitchList{l.l.Slice(idx, end)}
}

func (l PitchList) Set(idx uint64, v Pitch) PitchList {
	return PitchList{l.l.Set(idx, v.NomsValue())}
}

func (l PitchList) Append(v ...Pitch) PitchList {
	return PitchList{l.l.Append(l.fromElemSlice(v)...)}
}

func (l PitchList) Insert(idx uint64, v ...Pitch) PitchList {
	return PitchList{l.l.Insert(idx, l.fromElemSlice(v)...)}
}

func (l PitchList) Remove(idx uint64, end uint64) PitchList {
	return PitchList{l.l.Remove(idx, end)}
}

func (l PitchList) RemoveAt(idx uint64) PitchList {
	return PitchList{(l.l.RemoveAt(idx))}
}

func (l PitchList) fromElemSlice(p []Pitch) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v.NomsValue()
	}
	return r
}

// StringStringMap

type StringStringMap struct {
	m types.Map
}

type StringStringMapIterCallback (func(k types.String, v types.String) (stop bool))

func NewStringStringMap() StringStringMap {
	return StringStringMap{types.NewMap()}
}

func StringStringMapFromVal(p types.Value) StringStringMap {
	return StringStringMap{p.(types.Map)}
}

func (m StringStringMap) NomsValue() types.Map {
	return m.m
}

func (m StringStringMap) Equals(p StringStringMap) bool {
	return m.m.Equals(p.m)
}

func (m StringStringMap) Ref() ref.Ref {
	return m.m.Ref()
}

func (m StringStringMap) Empty() bool {
	return m.m.Empty()
}

func (m StringStringMap) Len() uint64 {
	return m.m.Len()
}

func (m StringStringMap) Has(p types.String) bool {
	return m.m.Has(p)
}

func (m StringStringMap) Get(p types.String) types.String {
	return types.StringFromVal(m.m.Get(p))
}

func (m StringStringMap) Set(k types.String, v types.String) StringStringMap {
	return StringStringMapFromVal(m.m.Set(k, v))
}

// TODO: Implement SetM?

func (m StringStringMap) Remove(p types.String) StringStringMap {
	return StringStringMapFromVal(m.m.Remove(p))
}

func (m StringStringMap) Iter(cb StringStringMapIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(types.StringFromVal(k), types.StringFromVal(v))
	})
}

// Pitch

type Pitch struct {
	m types.Map
}

func NewPitch() Pitch {
	return Pitch{types.NewMap()}
}

func PitchFromVal(v types.Value) Pitch {
	return Pitch{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s Pitch) NomsValue() types.Map {
	return s.m
}

func (s Pitch) Equals(p Pitch) bool {
	return s.m.Equals(p.m)
}

func (s Pitch) Ref() ref.Ref {
	return s.m.Ref()
}

func (s Pitch) Z() types.Float64 {
	return types.Float64FromVal(s.m.Get(types.NewString("Z")))
}

func (s Pitch) SetZ(p types.Float64) Pitch {
	return PitchFromVal(s.m.Set(types.NewString("Z"), p))
}

func (s Pitch) X() types.Float64 {
	return types.Float64FromVal(s.m.Get(types.NewString("X")))
}

func (s Pitch) SetX(p types.Float64) Pitch {
	return PitchFromVal(s.m.Set(types.NewString("X"), p))
}

// StringPitchListMap

type StringPitchListMap struct {
	m types.Map
}

type StringPitchListMapIterCallback (func(k types.String, v PitchList) (stop bool))

func NewStringPitchListMap() StringPitchListMap {
	return StringPitchListMap{types.NewMap()}
}

func StringPitchListMapFromVal(p types.Value) StringPitchListMap {
	return StringPitchListMap{p.(types.Map)}
}

func (m StringPitchListMap) NomsValue() types.Map {
	return m.m
}

func (m StringPitchListMap) Equals(p StringPitchListMap) bool {
	return m.m.Equals(p.m)
}

func (m StringPitchListMap) Ref() ref.Ref {
	return m.m.Ref()
}

func (m StringPitchListMap) Empty() bool {
	return m.m.Empty()
}

func (m StringPitchListMap) Len() uint64 {
	return m.m.Len()
}

func (m StringPitchListMap) Has(p types.String) bool {
	return m.m.Has(p)
}

func (m StringPitchListMap) Get(p types.String) PitchList {
	return PitchListFromVal(m.m.Get(p))
}

func (m StringPitchListMap) Set(k types.String, v PitchList) StringPitchListMap {
	return StringPitchListMapFromVal(m.m.Set(k, v.NomsValue()))
}

// TODO: Implement SetM?

func (m StringPitchListMap) Remove(p types.String) StringPitchListMap {
	return StringPitchListMapFromVal(m.m.Remove(p))
}

func (m StringPitchListMap) Iter(cb StringPitchListMapIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(types.StringFromVal(k), PitchListFromVal(v))
	})
}


// This file was generated by nomdl/codegen.

package main

import (
	"github.com/attic-labs/noms/chunks"
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

var __mainPackageInFile_picasa_CachedRef ref.Ref

// This function builds up a Noms value that describes the type
// package implemented by this file and registers it with the global
// type package definition cache.
func init() {
	p := types.NewPackage([]types.Type{
		types.MakeStructType("User",
			[]types.Field{
				types.Field{"Id", types.MakePrimitiveType(types.StringKind), false},
				types.Field{"Name", types.MakePrimitiveType(types.StringKind), false},
				types.Field{"Albums", types.MakeCompoundType(types.MapKind, types.MakePrimitiveType(types.StringKind), types.MakeType(ref.Ref{}, 1)), false},
			},
			types.Choices{},
		),
		types.MakeStructType("Album",
			[]types.Field{
				types.Field{"Id", types.MakePrimitiveType(types.StringKind), false},
				types.Field{"Title", types.MakePrimitiveType(types.StringKind), false},
				types.Field{"Photos", types.MakeCompoundType(types.SetKind, types.MakeType(ref.Parse("sha1-10004087fdbc623873c649d28aa59f4e066d374e"), 0)), false},
			},
			types.Choices{},
		),
	}, []ref.Ref{
		ref.Parse("sha1-10004087fdbc623873c649d28aa59f4e066d374e"),
	})
	__mainPackageInFile_picasa_CachedRef = types.RegisterPackage(&p)
}

// User

type User struct {
	_Id     string
	_Name   string
	_Albums MapOfStringToAlbum

	ref *ref.Ref
}

func NewUser() User {
	return User{
		_Id:     "",
		_Name:   "",
		_Albums: NewMapOfStringToAlbum(),

		ref: &ref.Ref{},
	}
}

var __typeForUser types.Type

func (m User) Type() types.Type {
	return __typeForUser
}

func init() {
	__typeForUser = types.MakeType(__mainPackageInFile_picasa_CachedRef, 0)
	types.RegisterStruct(__typeForUser, builderForUser, readerForUser)
}

func builderForUser(values []types.Value) types.Value {
	i := 0
	s := User{ref: &ref.Ref{}}
	s._Id = values[i].(types.String).String()
	i++
	s._Name = values[i].(types.String).String()
	i++
	s._Albums = values[i].(MapOfStringToAlbum)
	i++
	return s
}

func readerForUser(v types.Value) []types.Value {
	values := []types.Value{}
	s := v.(User)
	values = append(values, types.NewString(s._Id))
	values = append(values, types.NewString(s._Name))
	values = append(values, s._Albums)
	return values
}

func (s User) Equals(other types.Value) bool {
	return other != nil && __typeForUser.Equals(other.Type()) && s.Ref() == other.Ref()
}

func (s User) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s User) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, __typeForUser.Chunks()...)
	chunks = append(chunks, s._Albums.Chunks()...)
	return
}

func (s User) ChildValues() (ret []types.Value) {
	ret = append(ret, types.NewString(s._Id))
	ret = append(ret, types.NewString(s._Name))
	ret = append(ret, s._Albums)
	return
}

func (s User) Id() string {
	return s._Id
}

func (s User) SetId(val string) User {
	s._Id = val
	s.ref = &ref.Ref{}
	return s
}

func (s User) Name() string {
	return s._Name
}

func (s User) SetName(val string) User {
	s._Name = val
	s.ref = &ref.Ref{}
	return s
}

func (s User) Albums() MapOfStringToAlbum {
	return s._Albums
}

func (s User) SetAlbums(val MapOfStringToAlbum) User {
	s._Albums = val
	s.ref = &ref.Ref{}
	return s
}

// Album

type Album struct {
	_Id     string
	_Title  string
	_Photos SetOfRemotePhoto

	ref *ref.Ref
}

func NewAlbum() Album {
	return Album{
		_Id:     "",
		_Title:  "",
		_Photos: NewSetOfRemotePhoto(),

		ref: &ref.Ref{},
	}
}

var __typeForAlbum types.Type

func (m Album) Type() types.Type {
	return __typeForAlbum
}

func init() {
	__typeForAlbum = types.MakeType(__mainPackageInFile_picasa_CachedRef, 1)
	types.RegisterStruct(__typeForAlbum, builderForAlbum, readerForAlbum)
}

func builderForAlbum(values []types.Value) types.Value {
	i := 0
	s := Album{ref: &ref.Ref{}}
	s._Id = values[i].(types.String).String()
	i++
	s._Title = values[i].(types.String).String()
	i++
	s._Photos = values[i].(SetOfRemotePhoto)
	i++
	return s
}

func readerForAlbum(v types.Value) []types.Value {
	values := []types.Value{}
	s := v.(Album)
	values = append(values, types.NewString(s._Id))
	values = append(values, types.NewString(s._Title))
	values = append(values, s._Photos)
	return values
}

func (s Album) Equals(other types.Value) bool {
	return other != nil && __typeForAlbum.Equals(other.Type()) && s.Ref() == other.Ref()
}

func (s Album) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s Album) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, __typeForAlbum.Chunks()...)
	chunks = append(chunks, s._Photos.Chunks()...)
	return
}

func (s Album) ChildValues() (ret []types.Value) {
	ret = append(ret, types.NewString(s._Id))
	ret = append(ret, types.NewString(s._Title))
	ret = append(ret, s._Photos)
	return
}

func (s Album) Id() string {
	return s._Id
}

func (s Album) SetId(val string) Album {
	s._Id = val
	s.ref = &ref.Ref{}
	return s
}

func (s Album) Title() string {
	return s._Title
}

func (s Album) SetTitle(val string) Album {
	s._Title = val
	s.ref = &ref.Ref{}
	return s
}

func (s Album) Photos() SetOfRemotePhoto {
	return s._Photos
}

func (s Album) SetPhotos(val SetOfRemotePhoto) Album {
	s._Photos = val
	s.ref = &ref.Ref{}
	return s
}

// MapOfStringToAlbum

type MapOfStringToAlbum struct {
	m   types.Map
	ref *ref.Ref
}

func NewMapOfStringToAlbum() MapOfStringToAlbum {
	return MapOfStringToAlbum{types.NewTypedMap(__typeForMapOfStringToAlbum), &ref.Ref{}}
}

func (m MapOfStringToAlbum) Equals(other types.Value) bool {
	return other != nil && __typeForMapOfStringToAlbum.Equals(other.Type()) && m.Ref() == other.Ref()
}

func (m MapOfStringToAlbum) Ref() ref.Ref {
	return types.EnsureRef(m.ref, m)
}

func (m MapOfStringToAlbum) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, m.Type().Chunks()...)
	chunks = append(chunks, m.m.Chunks()...)
	return
}

func (m MapOfStringToAlbum) ChildValues() []types.Value {
	return append([]types.Value{}, m.m.ChildValues()...)
}

// A Noms Value that describes MapOfStringToAlbum.
var __typeForMapOfStringToAlbum types.Type

func (m MapOfStringToAlbum) Type() types.Type {
	return __typeForMapOfStringToAlbum
}

func init() {
	__typeForMapOfStringToAlbum = types.MakeCompoundType(types.MapKind, types.MakePrimitiveType(types.StringKind), types.MakeType(__mainPackageInFile_picasa_CachedRef, 1))
	types.RegisterValue(__typeForMapOfStringToAlbum, builderForMapOfStringToAlbum, readerForMapOfStringToAlbum)
}

func builderForMapOfStringToAlbum(v types.Value) types.Value {
	return MapOfStringToAlbum{v.(types.Map), &ref.Ref{}}
}

func readerForMapOfStringToAlbum(v types.Value) types.Value {
	return v.(MapOfStringToAlbum).m
}

func (m MapOfStringToAlbum) Empty() bool {
	return m.m.Empty()
}

func (m MapOfStringToAlbum) Len() uint64 {
	return m.m.Len()
}

func (m MapOfStringToAlbum) Has(p string) bool {
	return m.m.Has(types.NewString(p))
}

func (m MapOfStringToAlbum) Get(p string) Album {
	return m.m.Get(types.NewString(p)).(Album)
}

func (m MapOfStringToAlbum) MaybeGet(p string) (Album, bool) {
	v, ok := m.m.MaybeGet(types.NewString(p))
	if !ok {
		return NewAlbum(), false
	}
	return v.(Album), ok
}

func (m MapOfStringToAlbum) Set(k string, v Album) MapOfStringToAlbum {
	return MapOfStringToAlbum{m.m.Set(types.NewString(k), v), &ref.Ref{}}
}

// TODO: Implement SetM?

func (m MapOfStringToAlbum) Remove(p string) MapOfStringToAlbum {
	return MapOfStringToAlbum{m.m.Remove(types.NewString(p)), &ref.Ref{}}
}

type MapOfStringToAlbumIterCallback func(k string, v Album) (stop bool)

func (m MapOfStringToAlbum) Iter(cb MapOfStringToAlbumIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(k.(types.String).String(), v.(Album))
	})
}

type MapOfStringToAlbumIterAllCallback func(k string, v Album)

func (m MapOfStringToAlbum) IterAll(cb MapOfStringToAlbumIterAllCallback) {
	m.m.IterAll(func(k, v types.Value) {
		cb(k.(types.String).String(), v.(Album))
	})
}

func (m MapOfStringToAlbum) IterAllP(concurrency int, cb MapOfStringToAlbumIterAllCallback) {
	m.m.IterAllP(concurrency, func(k, v types.Value) {
		cb(k.(types.String).String(), v.(Album))
	})
}

type MapOfStringToAlbumFilterCallback func(k string, v Album) (keep bool)

func (m MapOfStringToAlbum) Filter(cb MapOfStringToAlbumFilterCallback) MapOfStringToAlbum {
	out := m.m.Filter(func(k, v types.Value) bool {
		return cb(k.(types.String).String(), v.(Album))
	})
	return MapOfStringToAlbum{out, &ref.Ref{}}
}

// RefOfUser

type RefOfUser struct {
	target ref.Ref
	ref    *ref.Ref
}

func NewRefOfUser(target ref.Ref) RefOfUser {
	return RefOfUser{target, &ref.Ref{}}
}

func (r RefOfUser) TargetRef() ref.Ref {
	return r.target
}

func (r RefOfUser) Ref() ref.Ref {
	return types.EnsureRef(r.ref, r)
}

func (r RefOfUser) Equals(other types.Value) bool {
	return other != nil && __typeForRefOfUser.Equals(other.Type()) && r.Ref() == other.Ref()
}

func (r RefOfUser) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, r.Type().Chunks()...)
	chunks = append(chunks, r.target)
	return
}

func (r RefOfUser) ChildValues() []types.Value {
	return nil
}

// A Noms Value that describes RefOfUser.
var __typeForRefOfUser types.Type

func (r RefOfUser) Type() types.Type {
	return __typeForRefOfUser
}

func (r RefOfUser) Less(other types.OrderedValue) bool {
	return r.TargetRef().Less(other.(types.RefBase).TargetRef())
}

func init() {
	__typeForRefOfUser = types.MakeCompoundType(types.RefKind, types.MakeType(__mainPackageInFile_picasa_CachedRef, 0))
	types.RegisterRef(__typeForRefOfUser, builderForRefOfUser)
}

func builderForRefOfUser(r ref.Ref) types.Value {
	return NewRefOfUser(r)
}

func (r RefOfUser) TargetValue(cs chunks.ChunkSource) User {
	return types.ReadValue(r.target, cs).(User)
}

func (r RefOfUser) SetTargetValue(val User, cs chunks.ChunkSink) RefOfUser {
	return NewRefOfUser(types.WriteValue(val, cs))
}

// SetOfRemotePhoto

type SetOfRemotePhoto struct {
	s   types.Set
	ref *ref.Ref
}

func NewSetOfRemotePhoto() SetOfRemotePhoto {
	return SetOfRemotePhoto{types.NewTypedSet(__typeForSetOfRemotePhoto), &ref.Ref{}}
}

func (s SetOfRemotePhoto) Equals(other types.Value) bool {
	return other != nil && __typeForSetOfRemotePhoto.Equals(other.Type()) && s.Ref() == other.Ref()
}

func (s SetOfRemotePhoto) Ref() ref.Ref {
	return types.EnsureRef(s.ref, s)
}

func (s SetOfRemotePhoto) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, s.Type().Chunks()...)
	chunks = append(chunks, s.s.Chunks()...)
	return
}

func (s SetOfRemotePhoto) ChildValues() []types.Value {
	return append([]types.Value{}, s.s.ChildValues()...)
}

// A Noms Value that describes SetOfRemotePhoto.
var __typeForSetOfRemotePhoto types.Type

func (m SetOfRemotePhoto) Type() types.Type {
	return __typeForSetOfRemotePhoto
}

func init() {
	__typeForSetOfRemotePhoto = types.MakeCompoundType(types.SetKind, types.MakeType(ref.Parse("sha1-10004087fdbc623873c649d28aa59f4e066d374e"), 0))
	types.RegisterValue(__typeForSetOfRemotePhoto, builderForSetOfRemotePhoto, readerForSetOfRemotePhoto)
}

func builderForSetOfRemotePhoto(v types.Value) types.Value {
	return SetOfRemotePhoto{v.(types.Set), &ref.Ref{}}
}

func readerForSetOfRemotePhoto(v types.Value) types.Value {
	return v.(SetOfRemotePhoto).s
}

func (s SetOfRemotePhoto) Empty() bool {
	return s.s.Empty()
}

func (s SetOfRemotePhoto) Len() uint64 {
	return s.s.Len()
}

func (s SetOfRemotePhoto) Has(p RemotePhoto) bool {
	return s.s.Has(p)
}

type SetOfRemotePhotoIterCallback func(p RemotePhoto) (stop bool)

func (s SetOfRemotePhoto) Iter(cb SetOfRemotePhotoIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(v.(RemotePhoto))
	})
}

type SetOfRemotePhotoIterAllCallback func(p RemotePhoto)

func (s SetOfRemotePhoto) IterAll(cb SetOfRemotePhotoIterAllCallback) {
	s.s.IterAll(func(v types.Value) {
		cb(v.(RemotePhoto))
	})
}

func (s SetOfRemotePhoto) IterAllP(concurrency int, cb SetOfRemotePhotoIterAllCallback) {
	s.s.IterAllP(concurrency, func(v types.Value) {
		cb(v.(RemotePhoto))
	})
}

type SetOfRemotePhotoFilterCallback func(p RemotePhoto) (keep bool)

func (s SetOfRemotePhoto) Filter(cb SetOfRemotePhotoFilterCallback) SetOfRemotePhoto {
	out := s.s.Filter(func(v types.Value) bool {
		return cb(v.(RemotePhoto))
	})
	return SetOfRemotePhoto{out, &ref.Ref{}}
}

func (s SetOfRemotePhoto) Insert(p ...RemotePhoto) SetOfRemotePhoto {
	return SetOfRemotePhoto{s.s.Insert(s.fromElemSlice(p)...), &ref.Ref{}}
}

func (s SetOfRemotePhoto) Remove(p ...RemotePhoto) SetOfRemotePhoto {
	return SetOfRemotePhoto{s.s.Remove(s.fromElemSlice(p)...), &ref.Ref{}}
}

func (s SetOfRemotePhoto) Union(others ...SetOfRemotePhoto) SetOfRemotePhoto {
	return SetOfRemotePhoto{s.s.Union(s.fromStructSlice(others)...), &ref.Ref{}}
}

func (s SetOfRemotePhoto) First() RemotePhoto {
	return s.s.First().(RemotePhoto)
}

func (s SetOfRemotePhoto) fromStructSlice(p []SetOfRemotePhoto) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s SetOfRemotePhoto) fromElemSlice(p []RemotePhoto) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v
	}
	return r
}

// This file was generated by nomgen.
// To regenerate, run `go generate` in this package.

package main

import (
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

// TestStructBoolSetMap

type TestStructBoolSetMap struct {
	m types.Map
}

type TestStructBoolSetMapIterCallback (func(k TestStruct, v BoolSet) (stop bool))

func NewTestStructBoolSetMap() TestStructBoolSetMap {
	return TestStructBoolSetMap{types.NewMap()}
}

func TestStructBoolSetMapFromVal(p types.Value) TestStructBoolSetMap {
	return TestStructBoolSetMap{p.(types.Map)}
}

func (m TestStructBoolSetMap) NomsValue() types.Map {
	return m.m
}

func (m TestStructBoolSetMap) Equals(p TestStructBoolSetMap) bool {
	return m.m.Equals(p.m)
}

func (m TestStructBoolSetMap) Ref() ref.Ref {
	return m.m.Ref()
}

func (m TestStructBoolSetMap) Empty() bool {
	return m.m.Empty()
}

func (m TestStructBoolSetMap) Len() uint64 {
	return m.m.Len()
}

func (m TestStructBoolSetMap) Has(p TestStruct) bool {
	return m.m.Has(p.NomsValue())
}

func (m TestStructBoolSetMap) Get(p TestStruct) BoolSet {
	return BoolSetFromVal(m.m.Get(p.NomsValue()))
}

func (m TestStructBoolSetMap) Set(k TestStruct, v BoolSet) TestStructBoolSetMap {
	return TestStructBoolSetMapFromVal(m.m.Set(k.NomsValue(), v.NomsValue()))
}

// TODO: Implement SetM?

func (m TestStructBoolSetMap) Remove(p TestStruct) TestStructBoolSetMap {
	return TestStructBoolSetMapFromVal(m.m.Remove(p.NomsValue()))
}

func (m TestStructBoolSetMap) Iter(cb TestStructBoolSetMapIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(TestStructFromVal(k), BoolSetFromVal(v))
	})
}

// Int32List

type Int32List struct {
	l types.List
}

type Int32ListIterCallback (func (p types.Int32) (stop bool))

func NewInt32List() Int32List {
	return Int32List{types.NewList()}
}

func Int32ListFromVal(p types.Value) Int32List {
	return Int32List{p.(types.List)}
}

func (l Int32List) NomsValue() types.List {
	return l.l
}

func (l Int32List) Equals(p Int32List) bool {
	return l.l.Equals(p.l)
}

func (l Int32List) Ref() ref.Ref {
	return l.l.Ref()
}

func (l Int32List) Len() uint64 {
	return l.l.Len()
}

func (l Int32List) Empty() bool {
	return l.Len() == uint64(0)
}

func (l Int32List) Get(idx uint64) types.Int32 {
	return types.Int32FromVal(l.l.Get(idx))
}

func (l Int32List) Slice(idx uint64, end uint64) Int32List {
	return Int32List{l.l.Slice(idx, end)}
}

func (l Int32List) Set(idx uint64, v types.Int32) Int32List {
	return Int32List{l.l.Set(idx, v)}
}

func (l Int32List) Append(v ...types.Int32) Int32List {
	return Int32List{l.l.Append(l.fromElemSlice(v)...)}
}

func (l Int32List) Insert(idx uint64, v ...types.Int32) Int32List {
	return Int32List{l.l.Insert(idx, l.fromElemSlice(v)...)}
}

func (l Int32List) Remove(idx uint64, end uint64) Int32List {
	return Int32List{l.l.Remove(idx, end)}
}

func (l Int32List) RemoveAt(idx uint64) Int32List {
	return Int32List{(l.l.RemoveAt(idx))}
}

func (l Int32List) fromElemSlice(p []types.Int32) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v
	}
	return r
}

// StringFloat64Map

type StringFloat64Map struct {
	m types.Map
}

type StringFloat64MapIterCallback (func(k types.String, v types.Float64) (stop bool))

func NewStringFloat64Map() StringFloat64Map {
	return StringFloat64Map{types.NewMap()}
}

func StringFloat64MapFromVal(p types.Value) StringFloat64Map {
	return StringFloat64Map{p.(types.Map)}
}

func (m StringFloat64Map) NomsValue() types.Map {
	return m.m
}

func (m StringFloat64Map) Equals(p StringFloat64Map) bool {
	return m.m.Equals(p.m)
}

func (m StringFloat64Map) Ref() ref.Ref {
	return m.m.Ref()
}

func (m StringFloat64Map) Empty() bool {
	return m.m.Empty()
}

func (m StringFloat64Map) Len() uint64 {
	return m.m.Len()
}

func (m StringFloat64Map) Has(p types.String) bool {
	return m.m.Has(p)
}

func (m StringFloat64Map) Get(p types.String) types.Float64 {
	return types.Float64FromVal(m.m.Get(p))
}

func (m StringFloat64Map) Set(k types.String, v types.Float64) StringFloat64Map {
	return StringFloat64MapFromVal(m.m.Set(k, v))
}

// TODO: Implement SetM?

func (m StringFloat64Map) Remove(p types.String) StringFloat64Map {
	return StringFloat64MapFromVal(m.m.Remove(p))
}

func (m StringFloat64Map) Iter(cb StringFloat64MapIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(types.StringFromVal(k), types.Float64FromVal(v))
	})
}

// TestStruct

type TestStruct struct {
	m types.Map
}

func NewTestStruct() TestStruct {
	return TestStruct{types.NewMap()}
}

func TestStructFromVal(v types.Value) TestStruct {
	return TestStruct{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s TestStruct) NomsValue() types.Map {
	return s.m
}

func (s TestStruct) Equals(p TestStruct) bool {
	return s.m.Equals(p.m)
}

func (s TestStruct) Ref() ref.Ref {
	return s.m.Ref()
}

func (s TestStruct) Title() types.String {
	return types.StringFromVal(s.m.Get(types.NewString("title")))
}

func (s TestStruct) SetTitle(p types.String) TestStruct {
	return TestStructFromVal(s.m.Set(types.NewString("title"), p))
}

// BoolSet

type BoolSet struct {
	s types.Set
}

type BoolSetIterCallback (func(p types.Bool) (stop bool))

func NewBoolSet() BoolSet {
	return BoolSet{types.NewSet()}
}

func BoolSetFromVal(p types.Value) BoolSet {
	return BoolSet{p.(types.Set)}
}

func (s BoolSet) NomsValue() types.Set {
	return s.s
}

func (s BoolSet) Equals(p BoolSet) bool {
	return s.s.Equals(p.s)
}

func (s BoolSet) Ref() ref.Ref {
	return s.s.Ref()
}

func (s BoolSet) Empty() bool {
	return s.s.Empty()
}

func (s BoolSet) Len() uint64 {
	return s.s.Len()
}

func (s BoolSet) Has(p types.Bool) bool {
	return s.s.Has(p)
}

func (s BoolSet) Iter(cb BoolSetIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(types.BoolFromVal(v))
	})
}

func (s BoolSet) Insert(p ...types.Bool) BoolSet {
	return BoolSet{s.s.Insert(s.fromElemSlice(p)...)}
}

func (s BoolSet) Remove(p ...types.Bool) BoolSet {
	return BoolSet{s.s.Remove(s.fromElemSlice(p)...)}
}

func (s BoolSet) Union(others ...BoolSet) BoolSet {
	return BoolSet{s.s.Union(s.fromStructSlice(others)...)}
}

func (s BoolSet) Subtract(others ...BoolSet) BoolSet {
	return BoolSet{s.s.Subtract(s.fromStructSlice(others)...)}
}

func (s BoolSet) Any() types.Bool {
	return types.BoolFromVal(s.s.Any())
}

func (s BoolSet) fromStructSlice(p []BoolSet) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s BoolSet) fromElemSlice(p []types.Bool) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v
	}
	return r
}


// {{.StructName}}

type {{.StructName}} struct {
	m types.Map
}

type {{.StructName}}IterCallback (func(k {{.KeyName}}, v {{.ValueName}}) (stop bool))

func New{{.StructName}}() {{.StructName}} {
	return {{.StructName}}{types.NewMap()}
}

func {{.StructName}}FromVal(p types.Value) {{.StructName}} {
	return {{.StructName}}{p.(types.Map)}
}

func (m {{.StructName}}) NomsValue() types.Map {
	return m.m
}

func (m {{.StructName}}) Equals(p {{.StructName}}) bool {
	return m.m.Equals(p.m)
}

func (m {{.StructName}}) Ref() ref.Ref {
	return m.m.Ref()
}

func (m {{.StructName}}) Empty() bool {
	return m.m.Empty()
}

func (m {{.StructName}}) Len() uint64 {
	return m.m.Len()
}

func (m {{.StructName}}) Has(p {{.KeyName}}) bool {
	return m.m.Has(p{{toVal .KeyName}})
}

func (m {{.StructName}}) Get(p {{.KeyName}}) {{.ValueName}} {
	return {{fromVal .ValueName}}(m.m.Get(p{{toVal .KeyName}}))
}

func (m {{.StructName}}) Set(k {{.KeyName}}, v {{.ValueName}}) {{.StructName}} {
	return {{fromVal .StructName}}(m.m.Set(k{{toVal .KeyName}}, v{{toVal .ValueName}}))
}

// TODO: Implement SetM?

func (m {{.StructName}}) Remove(p {{.KeyName}}) {{.StructName}} {
	return {{fromVal .StructName}}(m.m.Remove(p{{toVal .KeyName}}))
}

func (m {{.StructName}}) Iter(cb {{.StructName}}IterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb({{fromVal .KeyName}}(k), {{fromVal .ValueName}}(v))
	})
}


// This file was generated by nomdl/codegen and then had references to this package (types) removed by hand. The $type field of Package was also manually set to the TypeRef that describes a Package directly.

package types

import (
	"github.com/attic-labs/noms/chunks"
	"github.com/attic-labs/noms/ref"
)

var __typesPackageInFile_package_CachedRef ref.Ref

// This function builds up a Noms value that describes the type
// package implemented by this file and registers it with the global
// type package definition cache.
func init() {
	p := PackageDef{
		NamedTypes: MapOfStringToTypeRefDef{
			"Package": MakeStructTypeRef("Package",
				[]Field{
					Field{"Dependencies", MakeCompoundTypeRef("", SetKind, MakeCompoundTypeRef("", RefKind, MakeTypeRef("Package", ref.Ref{}))), false},
					Field{"NamedTypes", MakeCompoundTypeRef("", MapKind, MakePrimitiveTypeRef(StringKind), MakePrimitiveTypeRef(TypeRefKind)), false},
				},
				Choices{},
			),
		},
	}.New()
	__typesPackageInFile_package_CachedRef = RegisterPackage(&p)
}

// SetOfPackage

type SetOfPackage struct {
	s Set
}

func NewSetOfPackage() SetOfPackage {
	return SetOfPackage{NewSet()}
}

func SetOfPackageFromVal(p Value) SetOfPackage {
	return SetOfPackage{p.(Set)}
}

func (s SetOfPackage) NomsValue() Value {
	return s.s
}

func (s SetOfPackage) Equals(other Value) bool {
	if other, ok := other.(SetOfPackage); ok {
		return s.s.Equals(other.s)
	}
	return false
}

func (s SetOfPackage) Ref() ref.Ref {
	return s.s.Ref()
}

func (s SetOfPackage) Chunks() []Future {
	return s.s.Chunks()
}

// A Noms Value that describes SetOfPackage.
var __typeRefForSetOfPackage TypeRef

func (m SetOfPackage) TypeRef() TypeRef {
	return __typeRefForSetOfPackage
}

func init() {
	__typeRefForSetOfPackage = MakeCompoundTypeRef("", SetKind, MakeTypeRef("Package", __typesPackageInFile_package_CachedRef))
	RegisterFromValFunction(__typeRefForSetOfPackage, func(v Value) NomsValue {
		return SetOfPackageFromVal(v)
	})
}

func (s SetOfPackage) Empty() bool {
	return s.s.Empty()
}

func (s SetOfPackage) Len() uint64 {
	return s.s.Len()
}

func (s SetOfPackage) Has(p Package) bool {
	return s.s.Has(p.NomsValue())
}

type SetOfPackageIterCallback func(p Package) (stop bool)

func (s SetOfPackage) Iter(cb SetOfPackageIterCallback) {
	s.s.Iter(func(v Value) bool {
		return cb(PackageFromVal(v))
	})
}

type SetOfPackageIterAllCallback func(p Package)

func (s SetOfPackage) IterAll(cb SetOfPackageIterAllCallback) {
	s.s.IterAll(func(v Value) {
		cb(PackageFromVal(v))
	})
}

type SetOfPackageFilterCallback func(p Package) (keep bool)

func (s SetOfPackage) Filter(cb SetOfPackageFilterCallback) SetOfPackage {
	ns := NewSetOfPackage()
	s.IterAll(func(v Package) {
		if cb(v) {
			ns = ns.Insert(v)
		}
	})
	return ns
}

func (s SetOfPackage) Insert(p ...Package) SetOfPackage {
	return SetOfPackage{s.s.Insert(s.fromElemSlice(p)...)}
}

func (s SetOfPackage) Remove(p ...Package) SetOfPackage {
	return SetOfPackage{s.s.Remove(s.fromElemSlice(p)...)}
}

func (s SetOfPackage) Union(others ...SetOfPackage) SetOfPackage {
	return SetOfPackage{s.s.Union(s.fromStructSlice(others)...)}
}

func (s SetOfPackage) Subtract(others ...SetOfPackage) SetOfPackage {
	return SetOfPackage{s.s.Subtract(s.fromStructSlice(others)...)}
}

func (s SetOfPackage) Any() Package {
	return PackageFromVal(s.s.Any())
}

func (s SetOfPackage) fromStructSlice(p []SetOfPackage) []Set {
	r := make([]Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s SetOfPackage) fromElemSlice(p []Package) []Value {
	r := make([]Value, len(p))
	for i, v := range p {
		r[i] = v.NomsValue()
	}
	return r
}

// Package

type Package struct {
	m Map
}

func NewPackage() Package {
	return Package{NewMap(
		NewString("$name"), NewString("Package"),
		NewString("$type"), MakeTypeRef("Package", __typesPackageInFile_package_CachedRef),
		NewString("Dependencies"), NewSet(),
		NewString("NamedTypes"), NewMap(),
	)}
}

// PackageDef defines a Package object, which represents a Noms type package.
// Dependencies is a set of refs that point to other type packages required to resolve all the types in this pacakge.
// NamedTypes is a lookup table for types defined in this package. These should all be EnumKind or StructKind. When traversing the definition of a given type, you may run into a TypeRef that IsUnresolved(). In that case, look it up by name in the NamedTypes of the appropriate package.
type PackageDef struct {
	Dependencies SetOfRefOfPackageDef
	NamedTypes   MapOfStringToTypeRefDef
}

func (def PackageDef) New() Package {
	return Package{
		NewMap(
			NewString("$name"), NewString("Package"),
			NewString("$type"), MakeTypeRef("Package", __typesPackageInFile_package_CachedRef),
			NewString("Dependencies"), def.Dependencies.New().NomsValue(),
			NewString("NamedTypes"), def.NamedTypes.New().NomsValue(),
		)}
}

func (s Package) Def() (d PackageDef) {
	d.Dependencies = SetOfRefOfPackageFromVal(s.m.Get(NewString("Dependencies"))).Def()
	d.NamedTypes = MapOfStringToTypeRefFromVal(s.m.Get(NewString("NamedTypes"))).Def()
	return
}

var __typeRefForPackage TypeRef

func (m Package) TypeRef() TypeRef {
	return __typeRefForPackage
}

func init() {
	__typeRefForPackage = MakeTypeRef("Package", __typesPackageInFile_package_CachedRef)
	RegisterFromValFunction(__typeRefForPackage, func(v Value) NomsValue {
		return PackageFromVal(v)
	})
}

func PackageFromVal(val Value) Package {
	// TODO: Validate here
	return Package{val.(Map)}
}

func (s Package) NomsValue() Value {
	return s.m
}

func (s Package) Equals(other Value) bool {
	if other, ok := other.(Package); ok {
		return s.m.Equals(other.m)
	}
	return false
}

func (s Package) Ref() ref.Ref {
	return s.m.Ref()
}

func (s Package) Chunks() []Future {
	return s.m.Chunks()
}

func (s Package) Dependencies() SetOfRefOfPackage {
	return SetOfRefOfPackageFromVal(s.m.Get(NewString("Dependencies")))
}

func (s Package) SetDependencies(val SetOfRefOfPackage) Package {
	return Package{s.m.Set(NewString("Dependencies"), val.NomsValue())}
}

func (s Package) NamedTypes() MapOfStringToTypeRef {
	return MapOfStringToTypeRefFromVal(s.m.Get(NewString("NamedTypes")))
}

func (s Package) SetNamedTypes(val MapOfStringToTypeRef) Package {
	return Package{s.m.Set(NewString("NamedTypes"), val.NomsValue())}
}

// SetOfRefOfPackage

type SetOfRefOfPackage struct {
	s Set
}

func NewSetOfRefOfPackage() SetOfRefOfPackage {
	return SetOfRefOfPackage{NewSet()}
}

type SetOfRefOfPackageDef map[ref.Ref]bool

func (def SetOfRefOfPackageDef) New() SetOfRefOfPackage {
	l := make([]Value, len(def))
	i := 0
	for d, _ := range def {
		l[i] = Ref{R: d}
		i++
	}
	return SetOfRefOfPackage{NewSet(l...)}
}

func (s SetOfRefOfPackage) Def() SetOfRefOfPackageDef {
	def := make(map[ref.Ref]bool, s.Len())
	s.s.Iter(func(v Value) bool {
		def[v.Ref()] = true
		return false
	})
	return def
}

func SetOfRefOfPackageFromVal(p Value) SetOfRefOfPackage {
	return SetOfRefOfPackage{p.(Set)}
}

func (s SetOfRefOfPackage) NomsValue() Value {
	return s.s
}

func (s SetOfRefOfPackage) Equals(other Value) bool {
	if other, ok := other.(SetOfRefOfPackage); ok {
		return s.s.Equals(other.s)
	}
	return false
}

func (s SetOfRefOfPackage) Ref() ref.Ref {
	return s.s.Ref()
}

func (s SetOfRefOfPackage) Chunks() []Future {
	return s.s.Chunks()
}

// A Noms Value that describes SetOfRefOfPackage.
var __typeRefForSetOfRefOfPackage TypeRef

func (m SetOfRefOfPackage) TypeRef() TypeRef {
	return __typeRefForSetOfRefOfPackage
}

func init() {
	__typeRefForSetOfRefOfPackage = MakeCompoundTypeRef("", SetKind, MakeCompoundTypeRef("", RefKind, MakeTypeRef("Package", __typesPackageInFile_package_CachedRef)))
	RegisterFromValFunction(__typeRefForSetOfRefOfPackage, func(v Value) NomsValue {
		return SetOfRefOfPackageFromVal(v)
	})
}

func (s SetOfRefOfPackage) Empty() bool {
	return s.s.Empty()
}

func (s SetOfRefOfPackage) Len() uint64 {
	return s.s.Len()
}

func (s SetOfRefOfPackage) Has(p RefOfPackage) bool {
	return s.s.Has(p.NomsValue())
}

type SetOfRefOfPackageIterCallback func(p RefOfPackage) (stop bool)

func (s SetOfRefOfPackage) Iter(cb SetOfRefOfPackageIterCallback) {
	s.s.Iter(func(v Value) bool {
		return cb(RefOfPackageFromVal(v))
	})
}

type SetOfRefOfPackageIterAllCallback func(p RefOfPackage)

func (s SetOfRefOfPackage) IterAll(cb SetOfRefOfPackageIterAllCallback) {
	// IT'S A HAAAAAACK!
	// Currently, ReadValue() automatically derefs refs. So, in some cases the value passed to the callback by s.s.IterAll() is actually a Package instead of Ref(Package). This works around that until we've fixed it.
	s.s.IterAll(func(v Value) {
		if r, ok := v.(Ref); ok {
			cb(RefOfPackageFromVal(r))
			return
		}
		cb(RefOfPackage{PackageFromVal(v).Ref()})
	})
}

type SetOfRefOfPackageFilterCallback func(p RefOfPackage) (keep bool)

func (s SetOfRefOfPackage) Filter(cb SetOfRefOfPackageFilterCallback) SetOfRefOfPackage {
	ns := NewSetOfRefOfPackage()
	s.IterAll(func(v RefOfPackage) {
		if cb(v) {
			ns = ns.Insert(v)
		}
	})
	return ns
}

func (s SetOfRefOfPackage) Insert(p ...RefOfPackage) SetOfRefOfPackage {
	return SetOfRefOfPackage{s.s.Insert(s.fromElemSlice(p)...)}
}

func (s SetOfRefOfPackage) Remove(p ...RefOfPackage) SetOfRefOfPackage {
	return SetOfRefOfPackage{s.s.Remove(s.fromElemSlice(p)...)}
}

func (s SetOfRefOfPackage) Union(others ...SetOfRefOfPackage) SetOfRefOfPackage {
	return SetOfRefOfPackage{s.s.Union(s.fromStructSlice(others)...)}
}

func (s SetOfRefOfPackage) Subtract(others ...SetOfRefOfPackage) SetOfRefOfPackage {
	return SetOfRefOfPackage{s.s.Subtract(s.fromStructSlice(others)...)}
}

func (s SetOfRefOfPackage) Any() RefOfPackage {
	// IT'S A HAAAAAACK!
	// Currently, ReadValue() automatically derefs refs. So, in some cases the value returned by s.s.Any() is actually a Package instead of Ref(Package). This works around that until we've fixed it.
	return RefOfPackage{PackageFromVal(s.s.Any()).Ref()}
}

func (s SetOfRefOfPackage) fromStructSlice(p []SetOfRefOfPackage) []Set {
	r := make([]Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s SetOfRefOfPackage) fromElemSlice(p []RefOfPackage) []Value {
	r := make([]Value, len(p))
	for i, v := range p {
		r[i] = v.NomsValue()
	}
	return r
}

// RefOfPackage

type RefOfPackage struct {
	r ref.Ref
}

func NewRefOfPackage(r ref.Ref) RefOfPackage {
	return RefOfPackage{r}
}

func (r RefOfPackage) Ref() ref.Ref {
	return r.r
}

func (r RefOfPackage) Equals(other Value) bool {
	if other, ok := other.(RefOfPackage); ok {
		return r.r == other.r
	}
	return false
}

func (r RefOfPackage) Chunks() []Future {
	return nil
}

func (r RefOfPackage) NomsValue() Value {
	return Ref{R: r.r}
}

func RefOfPackageFromVal(p Value) RefOfPackage {
	return RefOfPackage{p.(Ref).Ref()}
}

// A Noms Value that describes RefOfPackage.
var __typeRefForRefOfPackage TypeRef

func (m RefOfPackage) TypeRef() TypeRef {
	return __typeRefForRefOfPackage
}

func init() {
	__typeRefForRefOfPackage = MakeCompoundTypeRef("", RefKind, MakeTypeRef("Package", __typesPackageInFile_package_CachedRef))
	RegisterFromValFunction(__typeRefForRefOfPackage, func(v Value) NomsValue {
		return RefOfPackageFromVal(v)
	})
}

func (r RefOfPackage) GetValue(cs chunks.ChunkSource) Package {
	return PackageFromVal(ReadValue(r.r, cs))
}

func (r RefOfPackage) SetValue(val Package, cs chunks.ChunkSink) RefOfPackage {
	ref := WriteValue(val.NomsValue(), cs)
	return RefOfPackage{ref}
}

// MapOfStringToTypeRef

type MapOfStringToTypeRef struct {
	m Map
}

func NewMapOfStringToTypeRef() MapOfStringToTypeRef {
	return MapOfStringToTypeRef{NewMap()}
}

type MapOfStringToTypeRefDef map[string]TypeRef

func (def MapOfStringToTypeRefDef) New() MapOfStringToTypeRef {
	kv := make([]Value, 0, len(def)*2)
	for k, v := range def {
		kv = append(kv, NewString(k), v)
	}
	return MapOfStringToTypeRef{NewMap(kv...)}
}

func (m MapOfStringToTypeRef) Def() MapOfStringToTypeRefDef {
	def := make(map[string]TypeRef)
	m.m.Iter(func(k, v Value) bool {
		def[k.(String).String()] = v.(TypeRef)
		return false
	})
	return def
}

func MapOfStringToTypeRefFromVal(p Value) MapOfStringToTypeRef {
	// TODO: Validate here
	return MapOfStringToTypeRef{p.(Map)}
}

func (m MapOfStringToTypeRef) NomsValue() Value {
	return m.m
}

func (m MapOfStringToTypeRef) Equals(other Value) bool {
	if other, ok := other.(MapOfStringToTypeRef); ok {
		return m.m.Equals(other.m)
	}
	return false
}

func (m MapOfStringToTypeRef) Ref() ref.Ref {
	return m.m.Ref()
}

func (m MapOfStringToTypeRef) Chunks() []Future {
	return m.m.Chunks()
}

// A Noms Value that describes MapOfStringToTypeRef.
var __typeRefForMapOfStringToTypeRef TypeRef

func (m MapOfStringToTypeRef) TypeRef() TypeRef {
	return __typeRefForMapOfStringToTypeRef
}

func init() {
	__typeRefForMapOfStringToTypeRef = MakeCompoundTypeRef("", MapKind, MakePrimitiveTypeRef(StringKind), MakePrimitiveTypeRef(TypeRefKind))
	RegisterFromValFunction(__typeRefForMapOfStringToTypeRef, func(v Value) NomsValue {
		return MapOfStringToTypeRefFromVal(v)
	})
}

func (m MapOfStringToTypeRef) Empty() bool {
	return m.m.Empty()
}

func (m MapOfStringToTypeRef) Len() uint64 {
	return m.m.Len()
}

func (m MapOfStringToTypeRef) Has(p string) bool {
	return m.m.Has(NewString(p))
}

func (m MapOfStringToTypeRef) Get(p string) TypeRef {
	return m.m.Get(NewString(p)).(TypeRef)
}

func (m MapOfStringToTypeRef) Set(k string, v TypeRef) MapOfStringToTypeRef {
	return MapOfStringToTypeRef{m.m.Set(NewString(k), v)}
}

// TODO: Implement SetM?

func (m MapOfStringToTypeRef) Remove(p string) MapOfStringToTypeRef {
	return MapOfStringToTypeRef{m.m.Remove(NewString(p))}
}

type MapOfStringToTypeRefIterCallback func(k string, v TypeRef) (stop bool)

func (m MapOfStringToTypeRef) Iter(cb MapOfStringToTypeRefIterCallback) {
	m.m.Iter(func(k, v Value) bool {
		return cb(k.(String).String(), v.(TypeRef))
	})
}

type MapOfStringToTypeRefIterAllCallback func(k string, v TypeRef)

func (m MapOfStringToTypeRef) IterAll(cb MapOfStringToTypeRefIterAllCallback) {
	m.m.IterAll(func(k, v Value) {
		cb(k.(String).String(), v.(TypeRef))
	})
}

type MapOfStringToTypeRefFilterCallback func(k string, v TypeRef) (keep bool)

func (m MapOfStringToTypeRef) Filter(cb MapOfStringToTypeRefFilterCallback) MapOfStringToTypeRef {
	nm := NewMapOfStringToTypeRef()
	m.IterAll(func(k string, v TypeRef) {
		if cb(k, v) {
			nm = nm.Set(k, v)
		}
	})
	return nm
}

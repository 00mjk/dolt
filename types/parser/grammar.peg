{
package main

type namespaceIdent struct {
	namespace string
	id string
}
}

Package <- p:PackageName dd:Definition+ EOF {
	aliases := map[string]string{}
	usings := []TypeRef{}
	named := map[string]TypeRef{}
	for _, d := range dd.([]interface{}) {
		switch d := d.(type) {
		default:
			return nil, fmt.Errorf("Unknown definition: %v", d)
		case alias:
			if _, present := aliases[d.Name]; present {
				return nil, fmt.Errorf("Redefinition of " + d.Name)
			}
			aliases[d.Name] = d.Target
		case TypeRef:
			switch d.Kind() {
			default:
				return nil, fmt.Errorf("%v can't be defined at the top-level", d)
			case ListKind, MapKind, RefKind, SetKind:
				usings = append(usings, d)
			case EnumKind, StructKind:
				if _, present := named[d.Name]; present {
					return nil, fmt.Errorf("Redefinition of " + d.Name)
				}
				named[d.Name] = d
			}
		}
	}
	return Package{p.(string), aliases, usings, named}, nil
}

PackageName <- `package` _ n:QuotedNamespaceIdent _ {
	nsi := n.(namespaceIdent)
	return nsi.namespace + "." + nsi.id, nil
}

Definition <- Struct / Using / Alias / Enum

Alias <- `alias` _ i:Ident _ `=` _ `import` _ q:QuotedString _ {
	return alias{i.(string), q.(string)}, nil
}

Enum <- `enum` _ id:Ident _ `{` _ l:EnumEntry+ _ `}` _{
	entries := l.([]interface{})
	ids := make([]string, len(entries))
	for i, e := range entries {
		ids[i] = e.(string)
	}
	return MakeEnumTypeRef(id.(string), ids), nil
}

EnumEntry <- i:Ident _ {
	return i.(string), nil
}


Using <- `using` _ ct:CompoundType _ {
	return ct, nil
}


Struct <- `struct` _ i:Ident _ `{` _ l:StructEntry+ _ `}` _ {
	ll := l.([]interface{})
	var u UnionDesc
	fields := make([]Field, 0, len(ll))
	for _, e := range ll {
		switch e := e.(type) {
		case UnionDesc:
			if len(u.choices) != 0 {
				return nil, fmt.Errorf("Only one anonymous union per struct.")
			}
			u = e
		case Field:
			fields = append(fields, e)
		default:
			return nil, fmt.Errorf("Structs must be made up of field declarations and at most one anonymous union.")
		}
	}
	return MakeStructTypeRef(i.(string), fields, u), nil
}

StructEntry <- Union / Field


Union <- `union` _ `{` _ u:Field+ _ `}` _ {
	uu := u.([]interface{})
	fields := make([]Field, len(uu))
	for i, f := range uu {
		fields[i] = f.(Field)
	}
	return UnionDesc{fields}, nil
}

Field <- i:Ident _ `:` t:Type _ {
	return Field{i.(string), t.(TypeRef)}, nil
}

Type <- t:(PrimitiveType / CompoundType / Union / NamespaceIdent) {
	switch t := t.(type) {
	case TypeRef:
		return t, nil
	case UnionDesc:
		return TypeRef{Desc:t}, nil
	case namespaceIdent:
		return TypeRef{PkgRef:t.namespace, Name:t.id}, nil
	default:
		return nil, fmt.Errorf("%v is %T, not something that satisfies TypeRef", t, t)
	}
}

CompoundType <- `List` `(` t:Type `)` {
	return MakeCompoundTypeRef(ListKind, []TypeRef{t.(TypeRef)}), nil
} / `Map` `(` k:Type `,` _ v:Type `)` {
	return MakeCompoundTypeRef(MapKind, []TypeRef{k.(TypeRef), v.(TypeRef)}), nil
} / `Set` `(` t:Type `)` {
	return MakeCompoundTypeRef(SetKind, []TypeRef{t.(TypeRef)}), nil
} / `Ref` `(` t:Type `)` {
	return MakeCompoundTypeRef(RefKind, []TypeRef{t.(TypeRef)}), nil
}

PrimitiveType <- p:(`UInt64` / `UInt32` / `UInt16` / `UInt8` / `Int64` / `Int32` / `Int16` / `Int8` / `Float64` / `Float32` / `Bool` / `String` / `Blob` / `Value`) {
	return MakePrimitiveTypeRef(string(p.([]uint8))), nil
}

QuotedString <- `"` n:String `"` {
	return n.(string), nil
}

String <- [^"]* {
	return string(c.text), nil
}

QuotedNamespaceIdent <- `"` n:NamespaceIdent `"` {
	return n, nil
}

NamespaceIdent <- n:(Ident '.')* id:Ident {
	nn := n.([]interface{})
	ns := make([]string, len(nn))
	for i, e := range nn {
		ns[i] = e.([]interface{})[0].(string)
	}
	return namespaceIdent{strings.Join(ns, "."), id.(string)}, nil
}

Ident <- [\pL_] [\pL\pN_]* {
	return string(c.text), nil
}

_ "optional whitespace" <- [\r\n\t\pZ]* {
	return nil, nil
}

EOF <- _ !.

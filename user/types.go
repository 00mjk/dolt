// This file was generated by nomgen.
// To regenerate, run `go generate` in this package.

package user

import (
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

// UserSet

type UserSet struct {
	s types.Set
}

type UserSetIterCallback (func (p User) (stop bool))

func NewUserSet() UserSet {
	return UserSet{types.NewSet()}
}

func UserSetFromVal(p types.Value) UserSet {
	return UserSet{p.(types.Set)}
}

func (s UserSet) NomsValue() types.Set {
	return s.s
}

func (s UserSet) Equals(p UserSet) bool {
	return s.s.Equals(p.s)
}

func (s UserSet) Ref() ref.Ref {
	return s.s.Ref()
}

func (s UserSet) Empty() bool {
	return s.s.Empty()
}

func (s UserSet) Len() uint64 {
	return s.s.Len()
}

func (s UserSet) Has(p User) bool {
	return s.s.Has(p.NomsValue())
}

func (s UserSet) Iter(cb UserSetIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(UserFromVal(v))
	})
}

func (s UserSet) Insert(p ...User) UserSet {
	return UserSet{s.s.Insert(s.fromElemSlice(p)...)}
}

func (s UserSet) Remove(p ...User) UserSet {
	return UserSet{s.s.Remove(s.fromElemSlice(p)...)}
}

func (s UserSet) Union(others ...UserSet) UserSet {
	return UserSet{s.s.Union(s.fromStructSlice(others)...)}
}

func (s UserSet) Subtract(others ...UserSet) UserSet {
	return UserSet{s.s.Subtract(s.fromStructSlice(others)...)}
}

func (s UserSet) Any() User {
	return UserFromVal(s.s.Any())
}

func (s UserSet) fromStructSlice(p []UserSet) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s UserSet) fromElemSlice(p []User) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v.NomsValue()
	}
	return r
}

// User

type User struct {
	m types.Map
}

func NewUser() User {
	return User{types.NewMap()}
}

func UserFromVal(v types.Value) User {
	return User{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s User) NomsValue() types.Map {
	return s.m
}

func (s User) Equals(p User) bool {
	return s.m.Equals(p.m)
}

func (s User) Ref() ref.Ref {
	return s.m.Ref()
}
func(s User) Email() types.String {
	return s.m.Get(types.NewString("email")).(types.String)
}

func (s User) SetEmail(p types.String) User {
	return UserFromVal(s.m.Set(types.NewString("email"), p))
}
func(s User) Apps() AppSet {
	return AppSetFromVal(s.m.Get(types.NewString("apps")))
}

func (s User) SetApps(p AppSet) User {
	return UserFromVal(s.m.Set(types.NewString("apps"), p.NomsValue()))
}
// AppSet

type AppSet struct {
	s types.Set
}

type AppSetIterCallback (func (p App) (stop bool))

func NewAppSet() AppSet {
	return AppSet{types.NewSet()}
}

func AppSetFromVal(p types.Value) AppSet {
	return AppSet{p.(types.Set)}
}

func (s AppSet) NomsValue() types.Set {
	return s.s
}

func (s AppSet) Equals(p AppSet) bool {
	return s.s.Equals(p.s)
}

func (s AppSet) Ref() ref.Ref {
	return s.s.Ref()
}

func (s AppSet) Empty() bool {
	return s.s.Empty()
}

func (s AppSet) Len() uint64 {
	return s.s.Len()
}

func (s AppSet) Has(p App) bool {
	return s.s.Has(p.NomsValue())
}

func (s AppSet) Iter(cb AppSetIterCallback) {
	s.s.Iter(func(v types.Value) bool {
		return cb(AppFromVal(v))
	})
}

func (s AppSet) Insert(p ...App) AppSet {
	return AppSet{s.s.Insert(s.fromElemSlice(p)...)}
}

func (s AppSet) Remove(p ...App) AppSet {
	return AppSet{s.s.Remove(s.fromElemSlice(p)...)}
}

func (s AppSet) Union(others ...AppSet) AppSet {
	return AppSet{s.s.Union(s.fromStructSlice(others)...)}
}

func (s AppSet) Subtract(others ...AppSet) AppSet {
	return AppSet{s.s.Subtract(s.fromStructSlice(others)...)}
}

func (s AppSet) Any() App {
	return AppFromVal(s.s.Any())
}

func (s AppSet) fromStructSlice(p []AppSet) []types.Set {
	r := make([]types.Set, len(p))
	for i, v := range p {
		r[i] = v.s
	}
	return r
}

func (s AppSet) fromElemSlice(p []App) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = v.NomsValue()
	}
	return r
}

// App

type App struct {
	m types.Map
}

func NewApp() App {
	return App{types.NewMap()}
}

func AppFromVal(v types.Value) App {
	return App{v.(types.Map)}
}

// TODO: This was going to be called Value() but it collides with root.value. We need some other place to put the built-in fields like Value() and Equals().
func (s App) NomsValue() types.Map {
	return s.m
}

func (s App) Equals(p App) bool {
	return s.m.Equals(p.m)
}

func (s App) Ref() ref.Ref {
	return s.m.Ref()
}
func(s App) Root() types.Value {
	return s.m.Get(types.NewString("root")).(types.Value)
}

func (s App) SetRoot(p types.Value) App {
	return AppFromVal(s.m.Set(types.NewString("root"), p))
}
func(s App) Id() types.String {
	return s.m.Get(types.NewString("id")).(types.String)
}

func (s App) SetId(p types.String) App {
	return AppFromVal(s.m.Set(types.NewString("id"), p))
}

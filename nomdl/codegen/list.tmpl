// {{.Name}}

type {{.Name}} struct {
	l types.List
}

func New{{.Name}}() {{.Name}} {
	return {{.Name}}{types.NewList()}
}

{{if .CanUseDef}}
	type {{.Name}}Def []{{defType .ElemType}}

	func (def {{.Name}}Def) New() {{.Name}} {
		l := make([]types.Value, len(def))
		for i, d := range def {
			l[i] = {{defToValue "d" .ElemType }}
		}
		return {{.Name}}{types.NewList(l...)}
	}

	func (l {{.Name}}) Def() {{.Name}}Def {
		d := make([]{{defType .ElemType}}, l.Len())
		for i := uint64(0); i < l.Len(); i++ {
			d[i] = {{valueToDef "l.l.Get(i)" .ElemType }}
		}
		return d
	}
{{end}}

func {{.Name}}FromVal(val types.Value) {{.Name}} {
	// TODO: Validate here
	return {{.Name}}{val.(types.List)}
}


func (l {{.Name}}) NomsValue() types.Value {
	return l.l
}

func (l {{.Name}}) Equals(other types.Value) bool {
	if other, ok := other.({{.Name}}); ok {
		return l.l.Equals(other.l)
	}
	return false
}

func (l {{.Name}}) Ref() ref.Ref {
	return l.l.Ref()
}

func (l {{.Name}}) Chunks() []types.Future {
	return l.l.Chunks()
}

{{template "type_ref.tmpl" .}}

func (l {{.Name}}) Len() uint64 {
	return l.l.Len()
}

func (l {{.Name}}) Empty() bool {
	return l.Len() == uint64(0)
}

func (l {{.Name}}) Get(i uint64) {{userType .ElemType}} {
	return {{valueToUser "l.l.Get(i)" .ElemType}}
}

func (l {{.Name}}) Slice(idx uint64, end uint64) {{.Name}} {
	return {{.Name}}{l.l.Slice(idx, end)}
}

func (l {{.Name}}) Set(i uint64, val {{userType .ElemType}}) {{.Name}} {
	return {{.Name}}{l.l.Set(i, {{userToValue "val" .ElemType}})}
}

func (l {{.Name}}) Append(v ...{{userType .ElemType}}) {{.Name}} {
	return {{.Name}}{l.l.Append(l.fromElemSlice(v)...)}
}

func (l {{.Name}}) Insert(idx uint64, v ...{{userType .ElemType}}) {{.Name}} {
	return {{.Name}}{l.l.Insert(idx, l.fromElemSlice(v)...)}
}

func (l {{.Name}}) Remove(idx uint64, end uint64) {{.Name}} {
	return {{.Name}}{l.l.Remove(idx, end)}
}

func (l {{.Name}}) RemoveAt(idx uint64) {{.Name}} {
	return {{.Name}}{(l.l.RemoveAt(idx))}
}

func (l {{.Name}}) fromElemSlice(p []{{userType .ElemType}}) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = {{userToValue "v" .ElemType}}
	}
	return r
}

type {{.Name}}IterCallback func(v {{userType .ElemType}}, i uint64) (stop bool)

func (l {{.Name}}) Iter(cb {{.Name}}IterCallback) {
	l.l.Iter(func(v types.Value, i uint64) bool {
		return cb({{valueToUser "v" .ElemType}}, i)
	})
}

type {{.Name}}IterAllCallback func(v {{userType .ElemType}}, i uint64)

func (l {{.Name}}) IterAll(cb {{.Name}}IterAllCallback) {
	l.l.IterAll(func(v types.Value, i uint64) {
		cb({{valueToUser "v" .ElemType}}, i)
	})
}

type {{.Name}}FilterCallback func(v {{userType .ElemType}}, i uint64) (keep bool)

func (l {{.Name}}) Filter(cb {{.Name}}FilterCallback) {{.Name}} {
	nl := New{{.Name}}()
	l.IterAll(func(v {{userType .ElemType}}, i uint64) {
		if cb(v, i) {
			nl = nl.Append(v)
		}
	})
	return nl
}

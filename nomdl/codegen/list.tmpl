// {{.Name}}

type {{.Name}} struct {
	l types.List
}

type {{.Name}}Def []{{defType .ElemType}}

func New{{.Name}}() {{.Name}} {
	return {{.Name}}{types.NewList()}
}

func (def {{.Name}}Def) New() {{.Name}} {
	l := make([]types.Value, len(def))
	for i, d := range def {
		l[i] = {{defToValue "d" .ElemType }}
	}
	return {{.Name}}{types.NewList(l...)}
}

func {{.Name}}FromVal(val types.Value) {{.Name}} {
	// TODO: Validate here
	return {{.Name}}{val.(types.List)}
}

func (self {{.Name}}) Def() {{.Name}}Def {
	l := make([]{{defType .ElemType}}, self.Len())
	for i := uint64(0); i < self.Len(); i++ {
		l[i] = {{valueToDef "self.l.Get(i)" .ElemType }}
	}
	return l
}

func (self {{.Name}}) NomsValue() types.Value {
	return self.l
}

func (l {{.Name}}) Equals(p {{.Name}}) bool {
	return l.l.Equals(p.l)
}

func (l {{.Name}}) Ref() ref.Ref {
	return l.l.Ref()
}

func (l {{.Name}}) Len() uint64 {
	return l.l.Len()
}

func (l {{.Name}}) Empty() bool {
	return l.Len() == uint64(0)
}

func (self {{.Name}}) Get(i uint64) {{userType .ElemType}} {
	return {{valueToUser "self.l.Get(i)" .ElemType}}
}

func (l {{.Name}}) Slice(idx uint64, end uint64) {{.Name}} {
	return {{.Name}}{l.l.Slice(idx, end)}
}

func (self {{.Name}}) Set(i uint64, val {{userType .ElemType}}) {{.Name}} {
	return {{.Name}}{self.l.Set(i, {{userToValue "val" .ElemType}})}
}

func (l {{.Name}}) Append(v ...{{userType .ElemType}}) {{.Name}} {
	return {{.Name}}{l.l.Append(l.fromElemSlice(v)...)}
}

func (l {{.Name}}) Insert(idx uint64, v ...{{userType .ElemType}}) {{.Name}} {
	return {{.Name}}{l.l.Insert(idx, l.fromElemSlice(v)...)}
}

func (l {{.Name}}) Remove(idx uint64, end uint64) {{.Name}} {
	return {{.Name}}{l.l.Remove(idx, end)}
}

func (l {{.Name}}) RemoveAt(idx uint64) {{.Name}} {
	return {{.Name}}{(l.l.RemoveAt(idx))}
}

func (l {{.Name}}) fromElemSlice(p []{{userType .ElemType}}) []types.Value {
	r := make([]types.Value, len(p))
	for i, v := range p {
		r[i] = {{userToValue "v" .ElemType}}
	}
	return r
}

{{$typesPackage := .TypesPackage}}

// {{.Name}}

type {{.Name}} struct {
	{{range .Fields}}_{{.Name}} {{userType .T}}
	{{if .Optional}}__optional{{.Name}} bool
	{{end}}{{end}}{{if .HasUnion}}__unionIndex uint32
	__unionValue {{$typesPackage}}Value{{end}}
	ref *ref.Ref
}

func New{{.Name}}() {{.Name}} {
	return {{.Name}}{
		{{range .Fields}}{{if (not .Optional)}}_{{.Name}}: {{userZero .T}},
		{{end}}{{end}}{{if .HasUnion}}__unionIndex: 0,
		__unionValue: {{valueZero .UnionZeroType}},{{end}}
		ref: &ref.Ref{},
	}
}

{{if .CanUseDef}}
	type {{.Name}}Def struct {
		{{range .Fields}}{{title .Name}} {{defType .T}}
		{{end}}{{if .HasUnion}}__unionIndex uint32
		__unionValue {{$typesPackage}}Value
	{{end}}}

	func (def {{.Name}}Def) New() {{.Name}} {
		return {{.Name}}{
			{{range .Fields}}_{{.Name}}: {{defToUser (print "def." (title .Name)) .T}},
			{{if .Optional}}__optional{{.Name}}: true,
			{{end}}{{end}}{{if .HasUnion}}__unionIndex: def.__unionIndex,
			__unionValue: def.__unionValue,
			{{end}}ref: &ref.Ref{},
		}
	}

	func (s {{.Name}}) Def() (d {{.Name}}Def) {
		{{range .Fields}}{{if .Optional}}if s.__optional{{.Name}}{ {{end}}d.{{title .Name}} = {{userToDef (printf `s._%s` .Name) .T}}
		{{if .Optional}} }
		{{end}}{{end}}{{if .HasUnion}}d.__unionIndex = s.__unionIndex
		d.__unionValue = s.__unionValue
		{{end}}return
	}
{{end}}

var __typeRefFor{{.Name}} {{$typesPackage}}TypeRef
var __typeDefFor{{.Name}} {{$typesPackage}}TypeRef

func (m {{.Name}}) TypeRef() {{$typesPackage}}TypeRef {
	return __typeRefFor{{.Name}}
}

func init() {
	__typeRefFor{{.Name}} = {{$typesPackage}}MakeTypeRef(__{{.PackageName}}PackageInFile_{{.FileID}}_CachedRef, {{.Ordinal}})
	__typeDefFor{{.Name}} = {{toTypesTypeRef .Type .FileID .PackageName}}
	{{$typesPackage}}RegisterStructBuilder(__typeRefFor{{.Name}}, builderFor{{.Name}})
}

func (s {{.Name}}) InternalImplementation() {{$typesPackage}}Struct {
	// TODO: Remove this
	m := map[string]{{$typesPackage}}Value{
		{{range .Fields}}{{if (not .Optional)}}"{{.Name}}": {{userToValue (printf "s._%s" .Name) .T}},
		{{end}}{{end}}
	}{{range .Fields}}{{if .Optional}}
	if s.__optional{{.Name}} {
		m["{{.Name}}"] = {{userToValue (printf "s._%s" .Name) .T}}
	}{{end}}{{end}}{{if .HasUnion}}
	m[__typeDefFor{{.Name}}.Desc.({{$typesPackage}}StructDesc).Union[s.__unionIndex].Name] = s.__unionValue{{end}}
	return {{$typesPackage}}NewStruct(__typeRefFor{{.Name}}, __typeDefFor{{.Name}}, m)
}

func builderFor{{.Name}}() chan {{$typesPackage}}Value {
	c := make(chan {{$typesPackage}}Value)
	s := {{.Name}}{ref: &ref.Ref{}}
	go func() { {{range .Fields}}{{if .Optional}}
		s.__optional{{.Name}} = bool((<-c).({{$typesPackage}}Bool))
		if s.__optional{{.Name}} {
			s._{{.Name}} = {{valueToUser "(<-c)" .T}}
		}{{else}}
		s._{{.Name}} = {{valueToUser "(<-c)" .T}}{{end}}{{end}}
		{{if .HasUnion}}s.__unionIndex = uint32((<-c).({{$typesPackage}}UInt32))
		s.__unionValue = <-c{{end}}
		c <- s	
	}()
	return c	
}

func (s {{.Name}}) Equals(other {{$typesPackage}}Value) bool {
	return other != nil && __typeRefFor{{.Name}}.Equals(other.TypeRef()) && s.Ref() == other.Ref()
}

func (s {{.Name}}) Ref() ref.Ref {
	return {{$typesPackage}}EnsureRef(s.ref, s)
}

func (s {{.Name}}) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, __typeRefFor{{.Name}}.Chunks()...)
	{{range .Fields}}{{if mayHaveChunks .T}}{{if .Optional}}if s.__optional{{.Name}} {
		{{end}}chunks = append(chunks, s._{{.Name}}.Chunks()...)
		{{if .Optional}} }
	{{end}}{{end}}{{end}}{{if .HasUnion}}chunks = append(chunks, s.__unionValue.Chunks()...)
	{{end}}return
}

{{$name := .Name}}
{{range $index, $field := .Fields}}
{{if .Optional}}
func (s {{$name}}) {{title .Name}}() (v {{userType .T}}, ok bool) {
	if s.__optional{{.Name}} {
		return s._{{.Name}}, true
	}
	return
}
{{else}}
func (s {{$name}}) {{title .Name}}() {{userType .T}} {
	return s._{{.Name}}
}
{{end}}
func (s {{$name}}) Set{{title .Name}}(val {{userType .T}}) {{$name}} {
	{{if .Optional}}s.__optional{{.Name}} = true
	{{end}}s._{{.Name}} = val
	s.ref = &ref.Ref{}
	return s
}
{{end}}

{{$canUseDef := .CanUseDef}}
{{range $index, $field := .Choices}}
	func (s {{$name}}) {{title .Name}}() (val {{userType .T}}, ok bool) {
		if s.__unionIndex != {{$index}} {
			return
		}
		return {{valueToUser "s.__unionValue" .T}}, true
	}

	func (s {{$name}}) Set{{title .Name}}(val {{userType .T}}) {{$name}} {
		s.__unionIndex = {{$index}}
		s.__unionValue = {{userToValue "val" .T}}
		s.ref = &ref.Ref{}
		return s
	}

	{{if $canUseDef}}
		func (def {{$name}}Def) {{title .Name}}() (val {{defType .T}}, ok bool) {
			if def.__unionIndex != {{$index}} {
				return
			}
			return {{valueToDef "def.__unionValue" .T}}, true
		}

		func (def {{$name}}Def) Set{{title .Name}}(val {{defType .T}}) {{$name}}Def {
			def.__unionIndex = {{$index}}
			def.__unionValue = {{defToValue "val" .T}}
			return def
		}
	{{end}}
{{end}}

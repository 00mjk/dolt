{{$typesPackage := .TypesPackage}}

// {{.Name}}

type {{.Name}} struct {
	r   ref.Ref
	ref *ref.Ref
}

func New{{.Name}}(r ref.Ref) {{.Name}} {
	return {{.Name}}{r, &ref.Ref{}}
}

func (r {{.Name}}) Ref() ref.Ref {
	return {{$typesPackage}}EnsureRef(r.ref, r)
}

func (r {{.Name}}) Equals(other {{$typesPackage}}Value) bool {
	if other, ok := other.({{.Name}}); ok {
		return r.Ref() == other.Ref()
	}
	return false
}

func (r {{.Name}}) Chunks() []{{$typesPackage}}Future {
	return r.TypeRef().Chunks()
}

func (r {{.Name}}) InternalImplementation() ref.Ref {
	return r.r
}

func {{.Name}}FromVal(val {{$typesPackage}}Value) {{.Name}} {
	// TODO: Do we still need FromVal?
	if val, ok := val.({{.Name}}); ok {
		return val
	}
	return {{.Name}}{val.({{$typesPackage}}Ref).Ref(), &ref.Ref{}}
}

{{template "type_ref.tmpl" .}}

func (r {{.Name}}) GetValue(cs chunks.ChunkSource) {{userType .ElemType}} {
	return {{valueToUser (printf "%sReadValue(r.r, cs)" $typesPackage) .ElemType}}
}

func (r {{.Name}}) SetValue(val {{userType .ElemType}}, cs chunks.ChunkSink) {{.Name}} {
	return {{.Name}}{ {{$typesPackage}}WriteValue({{userToValue "val" .ElemType}}, cs), &ref.Ref{}}
}

{{$typesPackage := .TypesPackage}}

// {{.Name}}

type {{.Name}} struct {
	target ref.Ref
	ref    *ref.Ref
}

func New{{.Name}}(target ref.Ref) {{.Name}} {
	return {{.Name}}{target, &ref.Ref{}}
}

func (r {{.Name}}) TargetRef() ref.Ref {
	return r.target
}

func (r {{.Name}}) Ref() ref.Ref {
	return {{$typesPackage}}EnsureRef(r.ref, r)
}

func (r {{.Name}}) Equals(other {{$typesPackage}}Value) bool {
	return other != nil && __typeFor{{.Name}}.Equals(other.Type()) && r.Ref() == other.Ref()
}

func (r {{.Name}}) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, r.Type().Chunks()...)
	chunks = append(chunks, r.target)
	return
}

func (r {{.Name}}) ChildValues() []{{$typesPackage}}Value {
	return nil
}

// A Noms Value that describes {{.Name}}.
var __typeFor{{.Name}} {{$typesPackage}}Type

func (r {{.Name}}) Type() {{$typesPackage}}Type {
	return __typeFor{{.Name}}
}

func (r {{.Name}}) Less(other {{$typesPackage}}OrderedValue) bool {
  return r.TargetRef().Less(other.({{$typesPackage}}RefBase).TargetRef())
}

func init() {
	__typeFor{{.Name}} = {{toTypesType .Type .FileID .PackageName}}
	{{$typesPackage}}RegisterRef(__typeFor{{.Name}}, builderFor{{.Name}})
}

func builderFor{{.Name}}(r ref.Ref) {{$typesPackage}}Value {
	return New{{.Name}}(r)
}

func (r {{.Name}}) TargetValue(cs chunks.ChunkStore) {{userType .ElemType}} {
	return {{valueToUser (printf "%sReadValue(r.target, cs)" $typesPackage) .ElemType}}
}

func (r {{.Name}}) SetTargetValue(val {{userType .ElemType}}, cs chunks.ChunkSink) {{.Name}} {
	return New{{.Name}}({{$typesPackage}}WriteValue({{userToValue "val" .ElemType}}, cs))
}

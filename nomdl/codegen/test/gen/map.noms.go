// This file was generated by nomdl/codegen.

package gen

import (
	"github.com/attic-labs/noms/chunks"
	"github.com/attic-labs/noms/ref"
	"github.com/attic-labs/noms/types"
)

// MapOfBoolToString

type MapOfBoolToString struct {
	m   types.Map
	cs  chunks.ChunkStore
	ref *ref.Ref
}

func NewMapOfBoolToString(cs chunks.ChunkStore) MapOfBoolToString {
	return MapOfBoolToString{types.NewTypedMap(cs, __typeForMapOfBoolToString), cs, &ref.Ref{}}
}

type MapOfBoolToStringDef map[bool]string

func (def MapOfBoolToStringDef) New(cs chunks.ChunkStore) MapOfBoolToString {
	kv := make([]types.Value, 0, len(def)*2)
	for k, v := range def {
		kv = append(kv, types.Bool(k), types.NewString(v))
	}
	return MapOfBoolToString{types.NewTypedMap(cs, __typeForMapOfBoolToString, kv...), cs, &ref.Ref{}}
}

func (m MapOfBoolToString) Def() MapOfBoolToStringDef {
	def := make(map[bool]string)
	m.m.Iter(func(k, v types.Value) bool {
		def[bool(k.(types.Bool))] = v.(types.String).String()
		return false
	})
	return def
}

func (m MapOfBoolToString) Equals(other types.Value) bool {
	return other != nil && __typeForMapOfBoolToString.Equals(other.Type()) && m.Ref() == other.Ref()
}

func (m MapOfBoolToString) Ref() ref.Ref {
	return types.EnsureRef(m.ref, m)
}

func (m MapOfBoolToString) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, m.Type().Chunks()...)
	chunks = append(chunks, m.m.Chunks()...)
	return
}

func (m MapOfBoolToString) ChildValues() []types.Value {
	return append([]types.Value{}, m.m.ChildValues()...)
}

// A Noms Value that describes MapOfBoolToString.
var __typeForMapOfBoolToString types.Type

func (m MapOfBoolToString) Type() types.Type {
	return __typeForMapOfBoolToString
}

func init() {
	__typeForMapOfBoolToString = types.MakeCompoundType(types.MapKind, types.MakePrimitiveType(types.BoolKind), types.MakePrimitiveType(types.StringKind))
	types.RegisterValue(__typeForMapOfBoolToString, builderForMapOfBoolToString, readerForMapOfBoolToString)
}

func builderForMapOfBoolToString(cs chunks.ChunkStore, v types.Value) types.Value {
	return MapOfBoolToString{v.(types.Map), cs, &ref.Ref{}}
}

func readerForMapOfBoolToString(v types.Value) types.Value {
	return v.(MapOfBoolToString).m
}

func (m MapOfBoolToString) Empty() bool {
	return m.m.Empty()
}

func (m MapOfBoolToString) Len() uint64 {
	return m.m.Len()
}

func (m MapOfBoolToString) Has(p bool) bool {
	return m.m.Has(types.Bool(p))
}

func (m MapOfBoolToString) Get(p bool) string {
	return m.m.Get(types.Bool(p)).(types.String).String()
}

func (m MapOfBoolToString) MaybeGet(p bool) (string, bool) {
	v, ok := m.m.MaybeGet(types.Bool(p))
	if !ok {
		return "", false
	}
	return v.(types.String).String(), ok
}

func (m MapOfBoolToString) Set(k bool, v string) MapOfBoolToString {
	return MapOfBoolToString{m.m.Set(types.Bool(k), types.NewString(v)), m.cs, &ref.Ref{}}
}

// TODO: Implement SetM?

func (m MapOfBoolToString) Remove(p bool) MapOfBoolToString {
	return MapOfBoolToString{m.m.Remove(types.Bool(p)), m.cs, &ref.Ref{}}
}

type MapOfBoolToStringIterCallback func(k bool, v string) (stop bool)

func (m MapOfBoolToString) Iter(cb MapOfBoolToStringIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(bool(k.(types.Bool)), v.(types.String).String())
	})
}

type MapOfBoolToStringIterAllCallback func(k bool, v string)

func (m MapOfBoolToString) IterAll(cb MapOfBoolToStringIterAllCallback) {
	m.m.IterAll(func(k, v types.Value) {
		cb(bool(k.(types.Bool)), v.(types.String).String())
	})
}

func (m MapOfBoolToString) IterAllP(concurrency int, cb MapOfBoolToStringIterAllCallback) {
	m.m.IterAllP(concurrency, func(k, v types.Value) {
		cb(bool(k.(types.Bool)), v.(types.String).String())
	})
}

type MapOfBoolToStringFilterCallback func(k bool, v string) (keep bool)

func (m MapOfBoolToString) Filter(cb MapOfBoolToStringFilterCallback) MapOfBoolToString {
	out := m.m.Filter(func(k, v types.Value) bool {
		return cb(bool(k.(types.Bool)), v.(types.String).String())
	})
	return MapOfBoolToString{out, m.cs, &ref.Ref{}}
}

// MapOfStringToValue

type MapOfStringToValue struct {
	m   types.Map
	cs  chunks.ChunkStore
	ref *ref.Ref
}

func NewMapOfStringToValue(cs chunks.ChunkStore) MapOfStringToValue {
	return MapOfStringToValue{types.NewTypedMap(cs, __typeForMapOfStringToValue), cs, &ref.Ref{}}
}

type MapOfStringToValueDef map[string]types.Value

func (def MapOfStringToValueDef) New(cs chunks.ChunkStore) MapOfStringToValue {
	kv := make([]types.Value, 0, len(def)*2)
	for k, v := range def {
		kv = append(kv, types.NewString(k), v)
	}
	return MapOfStringToValue{types.NewTypedMap(cs, __typeForMapOfStringToValue, kv...), cs, &ref.Ref{}}
}

func (m MapOfStringToValue) Def() MapOfStringToValueDef {
	def := make(map[string]types.Value)
	m.m.Iter(func(k, v types.Value) bool {
		def[k.(types.String).String()] = v
		return false
	})
	return def
}

func (m MapOfStringToValue) Equals(other types.Value) bool {
	return other != nil && __typeForMapOfStringToValue.Equals(other.Type()) && m.Ref() == other.Ref()
}

func (m MapOfStringToValue) Ref() ref.Ref {
	return types.EnsureRef(m.ref, m)
}

func (m MapOfStringToValue) Chunks() (chunks []ref.Ref) {
	chunks = append(chunks, m.Type().Chunks()...)
	chunks = append(chunks, m.m.Chunks()...)
	return
}

func (m MapOfStringToValue) ChildValues() []types.Value {
	return append([]types.Value{}, m.m.ChildValues()...)
}

// A Noms Value that describes MapOfStringToValue.
var __typeForMapOfStringToValue types.Type

func (m MapOfStringToValue) Type() types.Type {
	return __typeForMapOfStringToValue
}

func init() {
	__typeForMapOfStringToValue = types.MakeCompoundType(types.MapKind, types.MakePrimitiveType(types.StringKind), types.MakePrimitiveType(types.ValueKind))
	types.RegisterValue(__typeForMapOfStringToValue, builderForMapOfStringToValue, readerForMapOfStringToValue)
}

func builderForMapOfStringToValue(cs chunks.ChunkStore, v types.Value) types.Value {
	return MapOfStringToValue{v.(types.Map), cs, &ref.Ref{}}
}

func readerForMapOfStringToValue(v types.Value) types.Value {
	return v.(MapOfStringToValue).m
}

func (m MapOfStringToValue) Empty() bool {
	return m.m.Empty()
}

func (m MapOfStringToValue) Len() uint64 {
	return m.m.Len()
}

func (m MapOfStringToValue) Has(p string) bool {
	return m.m.Has(types.NewString(p))
}

func (m MapOfStringToValue) Get(p string) types.Value {
	return m.m.Get(types.NewString(p))
}

func (m MapOfStringToValue) MaybeGet(p string) (types.Value, bool) {
	v, ok := m.m.MaybeGet(types.NewString(p))
	if !ok {
		return types.Bool(false), false
	}
	return v, ok
}

func (m MapOfStringToValue) Set(k string, v types.Value) MapOfStringToValue {
	return MapOfStringToValue{m.m.Set(types.NewString(k), v), m.cs, &ref.Ref{}}
}

// TODO: Implement SetM?

func (m MapOfStringToValue) Remove(p string) MapOfStringToValue {
	return MapOfStringToValue{m.m.Remove(types.NewString(p)), m.cs, &ref.Ref{}}
}

type MapOfStringToValueIterCallback func(k string, v types.Value) (stop bool)

func (m MapOfStringToValue) Iter(cb MapOfStringToValueIterCallback) {
	m.m.Iter(func(k, v types.Value) bool {
		return cb(k.(types.String).String(), v)
	})
}

type MapOfStringToValueIterAllCallback func(k string, v types.Value)

func (m MapOfStringToValue) IterAll(cb MapOfStringToValueIterAllCallback) {
	m.m.IterAll(func(k, v types.Value) {
		cb(k.(types.String).String(), v)
	})
}

func (m MapOfStringToValue) IterAllP(concurrency int, cb MapOfStringToValueIterAllCallback) {
	m.m.IterAllP(concurrency, func(k, v types.Value) {
		cb(k.(types.String).String(), v)
	})
}

type MapOfStringToValueFilterCallback func(k string, v types.Value) (keep bool)

func (m MapOfStringToValue) Filter(cb MapOfStringToValueFilterCallback) MapOfStringToValue {
	out := m.m.Filter(func(k, v types.Value) bool {
		return cb(k.(types.String).String(), v)
	})
	return MapOfStringToValue{out, m.cs, &ref.Ref{}}
}
